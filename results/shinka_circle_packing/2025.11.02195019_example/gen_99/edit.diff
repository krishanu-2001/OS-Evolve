--- a/original.py
+++ b/original.py
@@ -1,233 +1,205 @@
 # EVOLVE-BLOCK-START
-"""Pipeline-based hybrid optimizer for n=26 circle packing"""
+"""Hybrid circle packing optimizer combining adaptive annealing and force refinement for n=26"""
 
 import numpy as np
-
-def construct_packing():
-    """
-    Top-level entry: runs the packing pipeline and returns the best centers and radii.
-    """
-    pipeline = PackingPipeline(n=26, margin=0.02, rng_seed=123)
-    centers, radii = pipeline.run()
-    return centers, radii
-
-class PackingPipeline:
-    def __init__(self, n, margin, rng_seed):
+from typing import List, Callable, Tuple
+
+class HybridCirclePacker:
+    def __init__(self,
+                 n: int = 26,
+                 max_sweeps: int = 30,
+                 tol: float = 1e-7,
+                 refine_iters: int = 1500,
+                 T0: float = 1e-2,
+                 alpha: float = 0.995,
+                 sigma_base: float = 0.015,
+                 sigma_multi: float = 0.03,
+                 stagnation_limit: int = 200,
+                 force_iters: int = 80,
+                 force_lr: float = 0.01):
         self.n = n
-        self.margin = margin
-        self.rng = np.random.default_rng(rng_seed)
-        # Candidate hexagonal row layouts summing to n
-        self.layouts = [
-            [6,5,6,5,4],
-            [5,6,5,6,4],
-            [6,6,5,5,4],
-            [5,5,6,6,4],
-            [6,5,5,6,4]
+        self.max_sweeps = max_sweeps
+        self.tol = tol
+        self.refine_iters = refine_iters
+        self.T0 = T0
+        self.alpha = alpha
+        self.sigma_base = sigma_base
+        self.sigma_multi = sigma_multi
+        self.stagnation_limit = stagnation_limit
+        self.force_iters = force_iters
+        self.force_lr = force_lr
+
+        # Diverse initial layouts: radial + multiple hex patterns
+        self.init_methods = [
+            self._radial_layout,
+            self._hex_layout([6,5,6,5,4]),
+            self._hex_layout([5,6,5,6,4]),
+            self._hex_layout([6,6,5,5,4]),
+            self._hex_layout([5,5,6,6,4]),
+            self._hex_layout([6,5,5,6,4]),
         ]
-        # Algorithmic parameters
-        self.num_restarts = 20
-        self.hill_iters = 2000
-        self.anneal_iters = 1000
-        self.physics_steps = 30
-
-    def run(self):
-        best_sum = -np.inf
-        best_centers = None
-        best_radii = None
-        for _ in range(self.num_restarts):
-            centers = self._initialize()
-            centers = self._hill_climb(centers)
-            centers = self._simulated_annealing(centers)
-            centers = self._physics_relax(centers)
-            radii = compute_max_radii(centers)
-            s = radii.sum()
-            if s > best_sum:
-                best_sum, best_centers, best_radii = s, centers.copy(), radii.copy()
-        return best_centers, best_radii
-
-    def _initialize(self):
-        # 40% hex layout, 20% corner-focused, 40% random uniform
-        r = self.rng.random()
-        if r < 0.4:
-            layout = self.rng.choice(self.layouts)
-            return self._hex_layout(layout)
-        elif r < 0.6:
-            return self._corner_layout()
-        else:
-            return self.rng.uniform(
-                self.margin, 1 - self.margin, size=(self.n, 2)
-            )
-
-    def _hex_layout(self, row_counts):
-        max_cols = max(row_counts)
-        dx = (1 - 2*self.margin) / max_cols
-        h = dx * np.sqrt(3) / 2
-        centers = np.zeros((self.n, 2))
-        idx = 0
-        for rid, cnt in enumerate(row_counts):
-            x0 = self.margin + (max_cols - cnt)*dx/2
-            y = self.margin + rid * h
-            for c in range(cnt):
-                centers[idx] = [x0 + c*dx, y]
-                idx += 1
-        return centers
-
-    def _corner_layout(self):
-        """
-        Place 4 circles near corners and distribute others along edges.
-        """
-        centers = np.zeros((self.n, 2))
-        margin = self.margin + 0.01
-        # corners
-        corners = [
-            [margin, margin],
-            [1-margin, margin],
-            [margin, 1-margin],
-            [1-margin, 1-margin]
-        ]
-        for i, c in enumerate(corners):
-            centers[i] = c
-        # distribute rest along edges
-        num_edge = self.n - len(corners)
-        per_edge = num_edge // 4
-        extra = num_edge % 4
-        idx = len(corners)
-        # bottom edge
-        for k in range(per_edge + (1 if extra > 0 else 0)):
-            t = (k+1)/(per_edge + (1 if extra > 0 else 0) + 1)
-            centers[idx] = [margin + t*(1-2*margin), margin]
-            idx += 1
-        # right edge
-        for k in range(per_edge + (1 if extra > 1 else 0)):
-            t = (k+1)/(per_edge + (1 if extra > 1 else 0) + 1)
-            centers[idx] = [1-margin, margin + t*(1-2*margin)]
-            idx += 1
-        # top edge
-        for k in range(per_edge + (1 if extra > 2 else 0)):
-            t = (k+1)/(per_edge + (1 if extra > 2 else 0) + 1)
-            centers[idx] = [1-margin - t*(1-2*margin), 1-margin]
-            idx += 1
-        # left edge
-        for k in range(per_edge):
-            t = (k+1)/(per_edge + 1)
-            centers[idx] = [margin, 1-margin - t*(1-2*margin)]
-            idx += 1
-        return centers
-
-    def _hill_climb(self, centers):
+
+    def optimize(self) -> Tuple[np.ndarray, np.ndarray]:
+        best_score = -np.inf
+        best_c, best_r = None, None
+        for init in self.init_methods:
+            centers = init()
+            centers = np.clip(centers, 0.0, 1.0)
+            radii = self._compute_radii(centers)
+            c_opt, r_opt = self._refine(centers, radii)
+            score = r_opt.sum()
+            if score > best_score:
+                best_score, best_c, best_r = score, c_opt.copy(), r_opt.copy()
+        return best_c, best_r
+
+    def _compute_radii(self, centers: np.ndarray) -> np.ndarray:
+        """Vectorized iterative radii computation limiting radii by borders and pairwise overlaps"""
+        radii = np.minimum.reduce([
+            centers[:,0], centers[:,1],
+            1 - centers[:,0], 1 - centers[:,1]
+        ])
+        for _ in range(self.max_sweeps):
+            diff = centers[:, None, :] - centers[None, :, :]
+            D = np.linalg.norm(diff, axis=2) + np.eye(self.n)
+            sumr = radii[:, None] + radii[None, :]
+            scale = np.minimum(1.0, D / sumr)
+            min_scale = scale.min(axis=1)
+            new_r = radii * min_scale
+            if np.max(np.abs(new_r - radii)) < self.tol:
+                break
+            radii = new_r
+        return radii
+
+    def _refine(self, centers: np.ndarray, radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
+        """Adaptive simulated annealing with multi-circle moves plus force-based relaxation"""
         best_c = centers.copy()
-        best_r = compute_max_radii(best_c)
-        best_s = best_r.sum()
-        alpha0 = ((1 - 2*self.margin) / max(map(len, self.layouts))) * 0.5
-        for t in range(self.hill_iters):
-            alpha = alpha0 * (1 - t / self.hill_iters)
-            cand_c = best_c.copy()
-            prob = 0.5 * (1 - t/self.hill_iters) + 0.1
-            if self.rng.random() < prob:
-                # adaptive multi-center move
-                k = self.rng.integers(2, 5)
-                idxs = self.rng.choice(self.n, size=k, replace=False)
-                for i in idxs:
-                    cand_c[i] += self.rng.uniform(-alpha, alpha, 2)
+        best_r = radii.copy()
+        best_score = radii.sum()
+
+        curr_c = best_c.copy()
+        curr_r = best_r.copy()
+        curr_score = best_score
+
+        T = self.T0
+        stagnation = 0
+
+        for _ in range(self.refine_iters):
+            if stagnation > self.stagnation_limit:
+                p_multi = 0.5
+                sigma = self.sigma_multi
             else:
-                i = int(self.rng.integers(self.n))
-                cand_c[i] += self.rng.uniform(-alpha, alpha, 2)
-            # clip into valid region
-            np.clip(cand_c, self.margin, 1-self.margin, out=cand_c)
-            cand_r = compute_max_radii(cand_c)
-            s = cand_r.sum()
-            if s > best_s:
-                best_s, best_c, best_r = s, cand_c, cand_r
-        return best_c
-
-    def _simulated_annealing(self, centers):
+                p_multi = 0.2
+                sigma = self.sigma_base
+
+            if np.random.rand() < p_multi:
+                idx = np.random.choice(self.n, size=3, replace=False)
+            else:
+                idx = [np.random.randint(self.n)]
+
+            c_new = curr_c.copy()
+            c_new[idx] += np.random.randn(len(idx), 2) * sigma
+            c_new = np.clip(c_new, 0.0, 1.0)
+
+            r_new = self._compute_radii(c_new)
+            score_new = r_new.sum()
+            dE = score_new - curr_score
+
+            if dE > 0 or np.random.rand() < np.exp(dE / T):
+                curr_c, curr_r, curr_score = c_new, r_new, score_new
+                if curr_score > best_score:
+                    best_c, best_r, best_score = curr_c.copy(), curr_r.copy(), curr_score
+                    stagnation = 0
+                else:
+                    stagnation += 1
+            else:
+                stagnation += 1
+
+            T *= self.alpha
+
+        # Final force-based relaxation to resolve overlaps and improve packing
+        c_force, r_force = self._force_refine(best_c)
+        if r_force.sum() > best_r.sum():
+            best_c, best_r = c_force, r_force
+
+        return best_c, best_r
+
+    def _radial_layout(self) -> np.ndarray:
+        c = np.zeros((self.n, 2))
+        c[0] = [0.5, 0.5]
+        r1, r2 = 0.28, 0.65
+        for i in range(8):
+            θ = 2*np.pi*i/8 + np.pi/16
+            c[i+1] = [0.5 + r1*np.cos(θ), 0.5 + r1*np.sin(θ)]
+        for i in range(13):
+            θ = 2*np.pi*i/13 + np.pi/13
+            c[i+9] = [0.5 + r2*np.cos(θ), 0.5 + r2*np.sin(θ)]
+        corners = [(0.1,0.1),(0.9,0.1),(0.1,0.9),(0.9,0.9)]
+        for k, p in enumerate(corners, start=22):
+            c[k] = p
+        return c
+
+    def _hex_layout(self, rows: List[int]) -> Callable[[], np.ndarray]:
+        def layout() -> np.ndarray:
+            margin = 0.1
+            max_row = max(rows)
+            dx = (1-2*margin)/(max_row-1) if max_row > 1 else 1-2*margin
+            dy = dx*np.sqrt(3)/2
+            y0 = (1 - dy*(len(rows)-1)) / 2
+            pts = []
+            for i, cnt in enumerate(rows):
+                y = y0 + i*dy
+                row_w = dx*(cnt-1) if cnt>1 else 0
+                x0 = (1 - row_w)/2
+                xs = x0 + np.arange(cnt)*dx if cnt>1 else [x0]
+                for x in xs:
+                    pts.append((x, y))
+            arr = np.array(pts)
+            if len(arr) > self.n:
+                return arr[:self.n]
+            if len(arr) < self.n:
+                pad = np.random.rand(self.n-len(arr),2)*(1-2*margin)+margin
+                return np.vstack([arr, pad])
+            return arr
+        return layout
+
+    def _force_refine(self, centers: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
         c = centers.copy()
-        r = compute_max_radii(c)
-        e = r.sum()
-        T0, T1 = 1e-2, 1e-4
-        for k in range(self.anneal_iters):
-            T = T0 * ((1 - k/self.anneal_iters) + (T1/T0)*(k/self.anneal_iters))
-            i = int(self.rng.integers(self.n))
-            cand = c.copy()
-            step = (1 - 2*self.margin) / max(map(len, self.layouts))
-            delta = self.rng.uniform(-step, step, 2) * (1 - k/self.anneal_iters)
-            cand[i] += delta
-            np.clip(cand, self.margin, 1-self.margin, out=cand)
-            cand_r = compute_max_radii(cand)
-            cand_e = cand_r.sum()
-            dE = cand_e - e
-            if dE > 0 or self.rng.random() < np.exp(dE / T):
-                c, r, e = cand, cand_r, cand_e
-        return c
-
-    def _physics_relax(self, centers):
-        c = centers.copy()
-        r = compute_max_radii(c)
-        for _ in range(self.physics_steps):
+        for _ in range(self.force_iters):
+            r = self._compute_radii(c)
             forces = np.zeros_like(c)
-            # pairwise repulsion
-            for i in range(self.n):
-                for j in range(i+1, self.n):
-                    dv = c[j] - c[i]
-                    dist = np.linalg.norm(dv)
-                    min_d = r[i] + r[j] + 1e-6
-                    if dist < min_d:
-                        dirv = dv/dist if dist>1e-8 else self.rng.normal(size=2)
-                        overlap = min_d - dist
-                        f = 0.2 * overlap * dirv
-                        forces[i] -= f
-                        forces[j] += f
-            # boundary forces
-            for i in range(self.n):
-                x,y = c[i]; ri = r[i]
-                if x - ri < self.margin: forces[i,0] += 0.2*(self.margin - (x-ri))
-                if x + ri > 1-self.margin: forces[i,0] -= 0.2*((x+ri)-(1-self.margin))
-                if y - ri < self.margin: forces[i,1] += 0.2*(self.margin - (y-ri))
-                if y + ri > 1-self.margin: forces[i,1] -= 0.2*((y+ri)-(1-self.margin))
-            c += 0.15 * forces
-            np.clip(c, self.margin, 1-self.margin, out=c)
-            r = compute_max_radii(c)
-        return c
-
-def compute_max_radii(centers):
-    """
-    Iterative relaxation enforcing border and pairwise constraints
-    until convergence or max iterations.
-    """
-    n = centers.shape[0]
-    # initial radii from borders
-    radii = np.minimum.reduce([
-        centers[:,0], centers[:,1],
-        1-centers[:,0], 1-centers[:,1]
-    ])
-    for _ in range(20):
-        changed = False
-        for i in range(n):
-            for j in range(i+1, n):
-                dv = centers[j] - centers[i]
-                d = np.hypot(dv[0], dv[1])
-                if d < 1e-8:
-                    if radii[i]>0 or radii[j]>0:
-                        radii[i]=radii[j]=0.0
-                        changed = True
-                else:
-                    ri, rj = radii[i], radii[j]
-                    if ri + rj > d:
-                        scale = d / (ri + rj)
-                        radii[i] *= scale
-                        radii[j] *= scale
-                        changed = True
-        if not changed:
-            break
-    return radii
-
+            diff = c[:,None,:] - c[None,:,:]
+            dist = np.linalg.norm(diff, axis=2) + np.eye(self.n)
+            sumr = r[:,None] + r[None,:]
+            overlap = sumr - dist
+            mask = overlap > 0
+            dirs = np.zeros_like(diff)
+            nz = dist > 0
+            dirs[nz] = diff[nz]/dist[nz][...,None]
+            f = overlap[...,None] * dirs
+            forces -= np.sum(np.where(mask[...,None], f, 0), axis=1)
+            forces += np.sum(np.where(mask[...,None], f, 0), axis=0)
+            # border repulsion
+            left  = np.where(c[:,0] < r, (r - c[:,0]), 0)
+            right = np.where(1-c[:,0] < r, (r - (1-c[:,0])), 0)
+            down  = np.where(c[:,1] < r, (r - c[:,1]), 0)
+            up    = np.where(1-c[:,1] < r, (r - (1-c[:,1])), 0)
+            forces[:,0] += left - right
+            forces[:,1] += down - up
+            c += self.force_lr * forces
+            c = np.clip(c, 0.0, 1.0)
+        return c, self._compute_radii(c)
+
+def construct_packing() -> Tuple[np.ndarray, np.ndarray]:
+    """Construct a 26‐circle packing in a unit square."""
+    packer = HybridCirclePacker()
+    return packer.optimize()
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii