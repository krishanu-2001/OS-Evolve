--- a/original.py
+++ b/original.py
@@ -1,180 +1,165 @@
 # EVOLVE-BLOCK-START
-"""Hybrid hexagonal initialization + adaptive hill-climbing + physics-based force refinement for n=26 circle packing"""
+"""Greedy largest empty circle initialization + physics relaxation for n=26 circle packing"""
 
 import numpy as np
 
 def construct_packing():
     """
-    Initialize 26 circle centers on multiple hexagonal lattice variants,
-    then perform adaptive hill-climbing local search to maximize sum of radii,
-    followed by physics-inspired force relaxation for fine-tuning.
+    Place 26 circles by greedy largest‐empty‐circle, then refine by physics relaxation.
     Returns:
         centers: np.array (26,2)
         radii:   np.array (26,)
     """
     n = 26
-    margin = 0.02
-    # Candidate row layouts summing to 26, exploring variations
-    candidate_row_layouts = [
-        [6, 5, 6, 5, 4],
-        [5, 6, 5, 6, 4],
-        [6, 6, 5, 5, 4],
-        [5, 5, 6, 6, 4],
-        [6, 5, 5, 6, 4]
-    ]
+    np.random.seed(0)
+    centers = []
+    radii   = []
+    # Parameters for sampling during greedy init
+    grid_n = 15          # grid resolution
+    rand_n = 300         # random samples per iteration
 
-    best_sum = -1
-    best_centers = None
-    best_radii = None
+    # Greedy placement
+    for k in range(n):
+        best_d = -1.0
+        best_pt = None
 
-    for row_counts in candidate_row_layouts:
-        max_cols = max(row_counts)
-        dx = (1 - 2*margin) / max_cols
-        h  = dx * np.sqrt(3) / 2
+        # generate candidate points: grid + random
+        xs = np.linspace(0.0, 1.0, grid_n)
+        ys = xs
+        # grid candidates
+        for x in xs:
+            for y in ys:
+                d = _clearance((x,y), centers, radii)
+                if d > best_d:
+                    best_d, best_pt = d, (x,y)
+        # random candidates
+        for _ in range(rand_n):
+            x = np.random.rand()
+            y = np.random.rand()
+            d = _clearance((x,y), centers, radii)
+            if d > best_d:
+                best_d, best_pt = d, (x,y)
 
-        centers = np.zeros((n, 2))
-        idx = 0
-        for rid, cnt in enumerate(row_counts):
-            x_start = margin + (max_cols - cnt) * dx / 2
-            y = margin + rid * h
-            for c in range(cnt):
-                centers[idx, 0] = x_start + c * dx
-                centers[idx, 1] = y
-                idx += 1
+        # local refinement around best_pt
+        bx, by = best_pt
+        bd = best_d
+        for _ in range(20):
+            # small random perturb
+            dx, dy = (np.random.randn()*bd*0.5, np.random.randn()*bd*0.5)
+            x2 = np.clip(bx + dx, 0.0, 1.0)
+            y2 = np.clip(by + dy, 0.0, 1.0)
+            d2 = _clearance((x2,y2), centers, radii)
+            if d2 > bd:
+                bx, by, bd = x2, y2, d2
+        centers.append([bx, by])
+        radii.append(bd if bd>0 else 0.0)
 
-        radii = compute_max_radii(centers)
-        s = radii.sum()
-        if s > best_sum:
-            best_sum = s
-            best_centers = centers
-            best_radii = radii
+    centers = np.array(centers)
+    # Force‐based relaxation
+    centers = _physics_relax(centers, steps=200, lr=0.1)
+    radii   = compute_max_radii(centers)
+    return centers, radii
 
-    # Adaptive hill-climbing parameters
-    iters = 6000
-    initial_alpha = dx * 0.5
-    rng = np.random.default_rng(42)
-
-    for t in range(iters):
-        alpha = initial_alpha * (1 - t / iters)
-        cand_centers = best_centers.copy()
-
-        # 20% chance to perturb multiple centers simultaneously
-        if rng.uniform() < 0.2:
-            count = rng.integers(2, 5)  # perturb 2 to 4 centers
-            indices = rng.choice(n, size=count, replace=False)
-            for i in indices:
-                delta = rng.uniform(-alpha, alpha, size=2)
-                cand_centers[i] += delta
-                cand_centers[i] = np.clip(cand_centers[i], margin, 1 - margin)
-        else:
-            i = int(rng.integers(n))
-            delta = rng.uniform(-alpha, alpha, size=2)
-            cand_centers[i] += delta
-            cand_centers[i] = np.clip(cand_centers[i], margin, 1 - margin)
-
-        cand_radii = compute_max_radii(cand_centers)
-        s = cand_radii.sum()
-        if s > best_sum:
-            best_sum = s
-            best_centers = cand_centers
-            best_radii = cand_radii
-
-    # Physics-inspired relaxation refinement
-    best_centers = physics_relaxation(best_centers, best_radii, steps=60, margin=margin)
-    best_radii = compute_max_radii(best_centers)
-    return best_centers, best_radii
-
-
-def physics_relaxation(centers, radii, steps=60, margin=0.02):
+def _clearance(pt, centers, radii):
     """
-    Physics-inspired repulsive force refinement of circle centers.
-    Args:
-        centers: (n,2) array of current centers
-        radii:   (n,) array of current radii
-        steps:   number of force relaxation steps
-        margin:  margin from square boundary
-    Returns:
-        refined_centers: (n,2) array
+    Compute minimal allowed radius at point pt from boundary and existing circles.
     """
-    n = centers.shape[0]
-    centers = centers.copy()
-    for _ in range(steps):
-        forces = np.zeros_like(centers)
-        # Pairwise repulsive forces for overlap or near-overlap
-        for i in range(n):
-            for j in range(i+1, n):
-                d_vec = centers[j] - centers[i]
-                dist = np.linalg.norm(d_vec)
-                min_dist = radii[i] + radii[j] + 1e-6
-                if dist < min_dist:
-                    if dist > 1e-8:
-                        direction = d_vec / dist
-                    else:
-                        direction = np.random.uniform(-1,1,2)
-                        direction /= np.linalg.norm(direction)
-                    overlap = min_dist - dist
-                    f = 0.2 * overlap * direction
-                    forces[i] -= f
-                    forces[j] += f
-        # Boundary repulsion
-        for i in range(n):
-            x, y = centers[i]
-            r = radii[i]
-            if x - r < margin:
-                forces[i,0] += 0.2 * (margin - (x - r))
-            if x + r > 1 - margin:
-                forces[i,0] -= 0.2 * ((x + r) - (1 - margin))
-            if y - r < margin:
-                forces[i,1] += 0.2 * (margin - (y - r))
-            if y + r > 1 - margin:
-                forces[i,1] -= 0.2 * ((y + r) - (1 - margin))
-        centers += 0.15 * forces
-        centers = np.clip(centers, margin, 1 - margin)
-    return centers
-
+    x, y = pt
+    # distance to walls
+    dmin = min(x, 1-x, y, 1-y)
+    # distance to existing circles minus their radii
+    for (cx, cy), r in zip(centers, radii):
+        d = np.hypot(cx - x, cy - y) - r
+        if d < dmin:
+            dmin = d
+            if dmin <= 0:
+                return -1.0
+    return dmin
 
 def compute_max_radii(centers):
     """
-    Given circle centers, compute the maximal non-overlapping radii
-    within the unit square by iteratively enforcing border and pairwise constraints.
+    Given circle centers, compute maximal radii by iteratively enforcing
+    boundary and pairwise non-overlap constraints.
     """
     n = centers.shape[0]
     radii = np.minimum.reduce([
-        centers[:,0],            # distance to left
-        centers[:,1],            # distance to bottom
-        1 - centers[:,0],        # right
-        1 - centers[:,1]         # top
-    ])
-
-    for _ in range(15):  # increased iterations for better convergence
+        centers[:,0], centers[:,1],
+        1-centers[:,0], 1-centers[:,1]
+    ]).copy()
+    # iterative refinement
+    for _ in range(20):
         changed = False
         for i in range(n):
             for j in range(i+1, n):
                 d = np.hypot(*(centers[i] - centers[j]))
                 if d <= 0:
-                    if radii[i] != 0.0 or radii[j] != 0.0:
+                    if radii[i] != 0 or radii[j] != 0:
                         radii[i] = radii[j] = 0.0
                         changed = True
                 else:
                     ri, rj = radii[i], radii[j]
                     if ri + rj > d:
                         scale = d / (ri + rj)
                         new_ri = ri * scale
                         new_rj = rj * scale
                         if new_ri < ri or new_rj < rj:
-                            radii[i] = new_ri
-                            radii[j] = new_rj
+                            radii[i], radii[j] = new_ri, new_rj
                             changed = True
         if not changed:
             break
     return radii
+
+def _physics_relax(centers, steps=200, lr=0.1):
+    """
+    Physics‐based force relaxation: at each step recompute radii, then
+    apply repulsive forces for overlaps and boundary pushes.
+    """
+    n = centers.shape[0]
+    c = centers.copy()
+    for _ in range(steps):
+        r = compute_max_radii(c)
+        F = np.zeros_like(c)
+        # pairwise repulsion
+        for i in range(n):
+            for j in range(i+1, n):
+                vec = c[j] - c[i]
+                dist = np.hypot(vec[0], vec[1])
+                if dist <= 0:
+                    continue
+                overlap = (r[i] + r[j]) - dist
+                if overlap > 0:
+                    dir = vec / dist
+                    f = overlap * dir * 0.5
+                    F[i] -= f
+                    F[j] += f
+        # boundary repulsion
+        for i in range(n):
+            x, y = c[i]
+            ri = r[i]
+            # left
+            if x - ri < 0:
+                F[i,0] += (ri - x)
+            # right
+            if x + ri > 1:
+                F[i,0] -= (x + ri - 1)
+            # bottom
+            if y - ri < 0:
+                F[i,1] += (ri - y)
+            # top
+            if y + ri > 1:
+                F[i,1] -= (y + ri - 1)
+        # update positions
+        c += lr * F
+        c = np.clip(c, 0.0, 1.0)
+    return c
+
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii
