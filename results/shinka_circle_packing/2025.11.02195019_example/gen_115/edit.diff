--- a/original.py
+++ b/original.py
@@ -1,209 +1,250 @@
 # EVOLVE-BLOCK-START
-"""Hybrid circle packing optimizer combining simulated annealing and constructor patterns for n=26"""
-
 import numpy as np
-from typing import List, Callable, Tuple
-
-class HybridCirclePacker:
-    def __init__(self,
-                 n: int = 26,
-                 init_methods: List[Callable[[], np.ndarray]] = None,
-                 max_sweeps: int = 20,
-                 tol: float = 1e-6,
-                 refine_iters: int = 1000,
-                 T0: float = 1e-2,
-                 alpha: float = 0.995,
-                 sigma_base: float = 0.02,
-                 sigma_multi: float = 0.05,
-                 stagnation_limit: int = 150,
-                 force_iters: int = 60,
-                 force_lr: float = 0.015):
-        self.n = n
-        self.max_sweeps = max_sweeps
-        self.tol = tol
-        self.refine_iters = refine_iters
-        self.T0 = T0
-        self.alpha = alpha
-        self.sigma_base = sigma_base
-        self.sigma_multi = sigma_multi
-        self.stagnation_limit = stagnation_limit
-        self.force_iters = force_iters
-        self.force_lr = force_lr
-
-        # Default initial layouts: radial, hex-grid, simple ring
-        self.init_methods = init_methods or [
-            self._radial_layout,
-            self._hex_layout([6,5,6,5,4]),
-            self._ring_layout
-        ]
-
-    def optimize(self) -> Tuple[np.ndarray, np.ndarray]:
-        best_score = -np.inf
-        best_c, best_r = None, None
-        for init in self.init_methods:
-            centers = init()
-            centers = np.clip(centers, 0.0, 1.0)
-            radii = self._compute_radii(centers)
-            c_opt, r_opt = self._refine(centers, radii)
-            score = r_opt.sum()
+
+def run_packing():
+    """Run the improved adaptive hybrid circle packing for n=26."""
+    centers, radii = adaptive_hybrid_packing()
+    sum_radii = np.sum(radii)
+    return centers, radii, sum_radii
+
+def adaptive_hybrid_packing():
+    n = 26
+    rng = np.random.default_rng(42)
+    best_score = -np.inf
+    best_centers, best_radii = None, None
+
+    # Multiple diverse initializations
+    for _ in range(4):
+        centers = initialize_layout(rng, n)
+        centers = clip_centers(centers)
+        radii = compute_max_radii(centers)
+        centers, radii = refine_pipeline(centers, radii, rng)
+        score = radii.sum()
+        if score > best_score:
+            best_score = score
+            best_centers, best_radii = centers.copy(), radii.copy()
+    return best_centers, best_radii
+
+def initialize_layout(rng, n):
+    """Diverse initial layouts: hex, ring, corner, random."""
+    choice = rng.random()
+    if choice < 0.4:
+        return hex_layout(rng, n)
+    elif choice < 0.7:
+        return ring_layout(rng, n)
+    elif choice < 0.9:
+        return corner_layout(rng, n)
+    else:
+        return rng.uniform(0.02, 0.98, size=(n,2))
+
+def clip_centers(centers):
+    """Ensure centers are within bounds with margin."""
+    return np.clip(centers, 0.02, 0.98)
+
+def hex_layout(rng, n):
+    """Hex grid layout with random perturbations."""
+    max_rows = 5
+    row_counts = [6, 5, 6, 5, 4]
+    max_cols = max(row_counts)
+    dx = (1 - 0.04) / max_cols
+    dy = dx * np.sqrt(3)/2
+    centers = []
+    y0 = 0.5 - dy * (len(row_counts)-1)/2
+    for i, cnt in enumerate(row_counts):
+        y = y0 + i*dy
+        x0 = 0.5 - (cnt-1)*dx/2
+        for c in range(cnt):
+            x = x0 + c*dx
+            centers.append([x, y])
+    centers = np.array(centers)
+    # Add small random perturbations
+    centers += rng.uniform(-0.02, 0.02, centers.shape)
+    return centers
+
+def ring_layout(rng, n):
+    """Circles along two concentric rings."""
+    centers = []
+    centers.append([0.5, 0.5])  # center
+    for i in range(8):
+        θ = 2*np.pi*i/8
+        centers.append([0.5 + 0.3*np.cos(θ), 0.5 + 0.3*np.sin(θ)])
+    for i in range(13):
+        θ = 2*np.pi*i/13
+        centers.append([0.5 + 0.65*np.cos(θ), 0.5 + 0.65*np.sin(θ)])
+    # fill remaining with random points
+    while len(centers) < n:
+        centers.append(rng.uniform(0.02, 0.98, 2))
+    return np.array(centers[:n])
+
+def corner_layout(rng, n):
+    """Corners + edges distribution."""
+    centers = np.zeros((n,2))
+    corners = np.array([[0.02,0.02],[0.98,0.02],[0.02,0.98],[0.98,0.98]])
+    centers[:4] = corners
+    remaining = n - 4
+    per_side = remaining // 4
+    extras = remaining % 4
+    # bottom edge
+    for i in range(per_side + (1 if extras>0 else 0)):
+        t = (i+1)/(per_side + (1 if extras>0 else 0)+1)
+        centers[4+i] = [0.02 + t*0.96, 0.02]
+    # right edge
+    for i in range(per_side + (1 if extras>1 else 0)):
+        t = (i+1)/(per_side + (1 if extras>1 else 0)+1)
+        centers[4+per_side+i] = [0.98, 0.02 + t*0.96]
+    # top edge
+    for i in range(per_side + (1 if extras>2 else 0)):
+        t = (i+1)/(per_side + (1 if extras>2 else 0)+1)
+        centers[4+2*per_side+i] = [0.98 - t*0.96, 0.98]
+    # left edge
+    for i in range(per_side):
+        t = (i+1)/(per_side+1)
+        centers[4+3*per_side+i] = [0.02, 0.98 - t*0.96]
+    return centers
+
+def compute_max_radii(centers):
+    """Iterative relaxation to find maximal radii respecting borders and overlaps."""
+    radii = np.minimum.reduce([centers[:,0], centers[:,1], 1-centers[:,0], 1-centers[:,1]])
+    for _ in range(20):
+        changed = False
+        for i in range(len(centers)):
+            for j in range(i+1, len(centers)):
+                d = np.linalg.norm(centers[i]-centers[j])
+                if d < 1e-8:
+                    continue
+                sum_r = radii[i] + radii[j]
+                if sum_r > d:
+                    scale = d / sum_r
+                    radii[i] *= scale
+                    radii[j] *= scale
+                    changed = True
+        if not changed:
+            break
+    return radii
+
+def refine_pipeline(centers, radii, rng):
+    """Main refinement pipeline: annealing + force relaxation + greedy adjustments."""
+    centers, radii = anneal_refinement(centers, radii, rng)
+    centers, radii = force_relaxation(centers, radii)
+    centers, radii = greedy_local_adjust(centers, radii, rng)
+    # global scaling to fill gaps
+    scale = compute_global_scale(centers, radii)
+    radii *= scale
+    return centers, radii
+
+def anneal_refinement(centers, radii, rng):
+    T_init, T_end = 1e-2, 1e-4
+    T = T_init
+    alpha = 0.995
+    best_centers, best_radii = centers.copy(), radii.copy()
+    best_score = radii.sum()
+    score = best_score
+    stagnation = 0
+    for step in range(1000):
+        p_multi = 0.4 if stagnation > 150 else 0.2
+        sigma = 0.02 if stagnation > 150 else 0.01
+        c_new = centers.copy()
+        if rng.random() < p_multi:
+            idxs = rng.choice(len(centers), size=3, replace=False)
+        else:
+            idxs = [rng.integers(len(centers))]
+        for i in idxs:
+            c_new[i] += rng.uniform(-sigma, sigma, 2)
+        c_new = clip_centers(c_new)
+        r_new = compute_max_radii(c_new)
+        s_new = r_new.sum()
+        dE = s_new - score
+        if dE > 0 or rng.random() < np.exp(dE / T):
+            centers, radii, score = c_new, r_new, s_new
             if score > best_score:
-                best_score, best_c, best_r = score, c_opt.copy(), r_opt.copy()
-        return best_c, best_r
-
-    def _compute_radii(self, centers: np.ndarray) -> np.ndarray:
-        """Border-limited initial radii + iterative pairwise scaling"""
-        radii = np.minimum.reduce([
-            centers[:,0], centers[:,1],
-            1 - centers[:,0], 1 - centers[:,1]
-        ])
-        for _ in range(self.max_sweeps):
-            changed = False
-            for i in range(self.n):
-                for j in range(i+1, self.n):
-                    d = np.linalg.norm(centers[i] - centers[j])
-                    if d <= 0: 
-                        continue
-                    if radii[i] + radii[j] > d:
-                        scale = d / (radii[i] + radii[j])
-                        radii[i] *= scale
-                        radii[j] *= scale
-                        changed = True
-            if not changed:
-                break
-        return radii
-
-    def _refine(self,
-                centers: np.ndarray,
-                radii: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
-        """Simulated-annealing style refinement + final force relaxation"""
-        best_c = centers.copy()
-        best_r = radii.copy()
-        best_score = best_r.sum()
-        curr_c, curr_r, curr_score = best_c.copy(), best_r.copy(), best_score
-        T = self.T0
-        stagnation = 0
-
-        for _ in range(self.refine_iters):
-            p_multi = 0.5 if stagnation > self.stagnation_limit else 0.2
-            sigma = self.sigma_multi if stagnation > self.stagnation_limit else self.sigma_base
-            if np.random.rand() < p_multi:
-                idx = np.random.choice(self.n, size=3, replace=False)
-            else:
-                idx = [np.random.randint(self.n)]
-            c_new = curr_c.copy()
-            c_new[idx] += np.random.randn(len(idx), 2) * sigma
-            c_new = np.clip(c_new, 0.0, 1.0)
-
-            r_new = self._compute_radii(c_new)
-            score_new = r_new.sum()
-            dE = score_new - curr_score
-            if dE > 0 or np.random.rand() < np.exp(dE / T):
-                curr_c, curr_r, curr_score = c_new, r_new, score_new
-                if curr_score > best_score:
-                    best_c, best_r, best_score = curr_c.copy(), curr_r.copy(), curr_score
-                    stagnation = 0
-                else:
-                    stagnation += 1
+                best_score = score
+                best_centers, best_radii = c_new.copy(), r_new.copy()
+                stagnation = 0
             else:
                 stagnation += 1
-            T *= self.alpha
-
-        # Final force-based relaxation
-        c_force, r_force = self._force_refine(best_c)
-        if r_force.sum() > best_r.sum():
-            best_c, best_r = c_force, r_force
-        return best_c, best_r
-
-    def _radial_layout(self) -> np.ndarray:
-        c = np.zeros((self.n, 2))
-        c[0] = [0.5, 0.5]
-        r1, r2 = 0.28, 0.65
-        for i in range(8):
-            θ = 2*np.pi*i/8 + np.pi/16
-            c[i+1] = [0.5 + r1*np.cos(θ), 0.5 + r1*np.sin(θ)]
-        for i in range(13):
-            θ = 2*np.pi*i/13 + np.pi/13
-            c[i+9] = [0.5 + r2*np.cos(θ), 0.5 + r2*np.sin(θ)]
-        corners = [(0.1,0.1),(0.9,0.1),(0.1,0.9),(0.9,0.9)]
-        for k, p in enumerate(corners, start=22):
-            c[k] = p
-        return c
-
-    def _hex_layout(self, rows: List[int]) -> Callable[[], np.ndarray]:
-        def layout() -> np.ndarray:
-            margin = 0.1
-            max_row = max(rows)
-            dx = (1 - 2*margin)/(max_row - 1) if max_row > 1 else 1 - 2*margin
-            dy = dx * np.sqrt(3)/2
-            y0 = (1 - dy*(len(rows)-1)) / 2
-            pts = []
-            for i, cnt in enumerate(rows):
-                y = y0 + i*dy
-                row_w = dx*(cnt-1) if cnt>1 else 0
-                x0 = (1 - row_w)/2
-                xs = x0 + np.arange(cnt)*dx if cnt>1 else [x0]
-                for x in xs:
-                    pts.append((x, y))
-            arr = np.array(pts)
-            if len(arr) > self.n:
-                return arr[:self.n]
-            if len(arr) < self.n:
-                pad = np.random.rand(self.n-len(arr),2)*(1-2*margin)+margin
-                return np.vstack([arr, pad])
-            return arr
-        return layout
-
-    def _ring_layout(self) -> np.ndarray:
-        c = np.zeros((self.n, 2))
-        c[0] = [0.5, 0.5]
-        for i in range(8):
-            θ = 2*np.pi*i/8
-            c[i+1] = [0.5 + 0.3*np.cos(θ), 0.5 + 0.3*np.sin(θ)]
-        for i in range(13):
-            θ = 2*np.pi*i/13
-            c[i+9] = [0.5 + 0.65*np.cos(θ), 0.5 + 0.65*np.sin(θ)]
-        # last circle as a corner
-        c[25] = [0.1, 0.1]
-        return c
-
-    def _force_refine(self, centers: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
-        c = centers.copy()
-        for _ in range(self.force_iters):
-            r = self._compute_radii(c)
-            forces = np.zeros_like(c)
-            diff = c[:,None,:] - c[None,:,:]
-            dist = np.linalg.norm(diff, axis=2) + np.eye(self.n)
-            sumr = r[:,None] + r[None,:]
-            overlap = sumr - dist
-            mask = overlap > 0
-            dirs = np.zeros_like(diff)
-            nz = dist > 0
-            dirs[nz] = diff[nz]/dist[nz][...,None]
-            f = overlap[...,None] * dirs
-            forces -= np.sum(np.where(mask[...,None], f, 0), axis=1)
-            forces += np.sum(np.where(mask[...,None], f, 0), axis=0)
-            # border repulsion
-            left  = np.where(c[:,0] < r, (r - c[:,0]), 0)
-            right = np.where(1-c[:,0] < r, (r - (1-c[:,0])), 0)
-            down  = np.where(c[:,1] < r, (r - c[:,1]), 0)
-            up    = np.where(1-c[:,1] < r, (r - (1-c[:,1])), 0)
-            forces[:,0] += left - right
-            forces[:,1] += down - up
-            c += self.force_lr * forces
-            c = np.clip(c, 0.0, 1.0)
-        return c, self._compute_radii(c)
-
-def construct_packing() -> Tuple[np.ndarray, np.ndarray]:
-    """Construct a 26‐circle packing in a unit square."""
-    packer = HybridCirclePacker()
-    return packer.optimize()
+        else:
+            stagnation += 1
+        T *= alpha
+    return best_centers, best_radii
+
+def force_relaxation(centers, radii):
+    """Physics-inspired force relaxation to improve packing."""
+    c = centers.copy()
+    for _ in range(30):
+        forces = np.zeros_like(c)
+        # pairwise repulsion
+        for i in range(len(c)):
+            for j in range(i+1, len(c)):
+                dv = c[j] - c[i]
+                d = np.linalg.norm(dv)
+                if d < 1e-8:
+                    continue
+                sum_r = radii[i] + radii[j]
+                if d < sum_r:
+                    overlap = sum_r - d
+                    dirv = dv/d if d>1e-8 else rng.normal(size=2)
+                    f = 0.2 * overlap * dirv
+                    forces[i] -= f
+                    forces[j] += f
+        # boundary forces
+        for i in range(len(c)):
+            for dim in range(2):
+                if c[i,dim] - radii[i] < 0.02:
+                    forces[i,dim] += 0.2*(0.02 - (c[i,dim]-radii[i]))
+                if c[i,dim] + radii[i] > 0.98:
+                    forces[i,dim] -= 0.2*((c[i,dim]+radii[i]) - 0.98)
+        c += 0.15 * forces
+        c = clip_centers(c)
+        radii = compute_max_radii(c)
+    return c, radii
+
+def greedy_local_adjust(centers, radii, rng):
+    """Local greedy adjustment: move each circle to maximize radius given others fixed."""
+    c = centers.copy()
+    for _ in range(2):
+        for i in range(len(c)):
+            best_r = 0
+            best_pos = c[i]
+            for _ in range(16):
+                candidate = c[i] + rng.uniform(-0.06, 0.06, 2)
+                candidate = np.clip(candidate, 0.02, 0.98)
+                # compute max radius at candidate
+                max_r = min(candidate[0], 1 - candidate[0], candidate[1], 1 - candidate[1])
+                for j in range(len(c)):
+                    if j == i:
+                        continue
+                    d = np.linalg.norm(candidate - c[j])
+                    max_r = min(max_r, d - radii[j])
+                if max_r > best_r:
+                    best_r = max_r
+                    best_pos = candidate
+            c[i] = best_pos
+    radii = compute_max_radii(c)
+    return c, radii
+
+def compute_global_scale(centers, radii):
+    """Compute maximum uniform scale to fit all circles without overlaps or border violations."""
+    factors = np.concatenate([
+        centers[:,0]/radii,
+        (1 - centers[:,0])/radii,
+        centers[:,1]/radii,
+        (1 - centers[:,1])/radii
+    ])
+    border_scale = np.min(factors)
+    # pairwise constraints
+    diff = centers[:,None,:] - centers[None,:,:]
+    dist = np.linalg.norm(diff, axis=2)
+    sum_r = radii[:,None] + radii[None,:]
+    mask = ~np.eye(len(centers), dtype=bool)
+    pair_scale = np.min((dist / sum_r)[mask])
+    return min(border_scale, pair_scale)
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii