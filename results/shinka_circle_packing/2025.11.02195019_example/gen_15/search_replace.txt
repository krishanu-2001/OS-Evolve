<NAME>
hybrid_physics_refinement
</NAME>

<DESCRIPTION>
After the hill-climbing phase, apply a brief physics-inspired "force relaxation" refinement: treat circles as soft disks repelling each other and the square boundary, and perform a few (e.g., 50) steps of force-based position updates. This can help break through local optima and resolve subtle overlaps or packing inefficiencies that hill-climbing alone misses. The code introduces a `physics_relaxation` function that computes and applies repulsive forces between overlapping or nearly-touching circles and between circles and the square edges, then updates the centers. This hybrid approach is inspired by the best-known results in the literature and may yield a denser packing and higher sum of radii.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    for t in range(iters):
        # decaying step size
        alpha = initial_alpha * (1 - t / iters)
        cand_centers = best_centers.copy()

        # With 20% probability, perturb multiple centers simultaneously
        if rng.uniform() < 0.2:
            count = rng.integers(2, 5)  # perturb 2 to 4 centers
            indices = rng.choice(n, size=count, replace=False)
            for i in indices:
                delta = rng.uniform(-alpha, alpha, size=2)
                cand_centers[i] += delta
                cand_centers[i] = np.clip(cand_centers[i], margin, 1 - margin)
        else:
            i = int(rng.integers(n))
            delta = rng.uniform(-alpha, alpha, size=2)
            cand_centers[i] += delta
            cand_centers[i] = np.clip(cand_centers[i], margin, 1 - margin)

        # recompute radii & evaluate
        cand_radii = compute_max_radii(cand_centers)
        s = cand_radii.sum()
        if s > best_sum:
            best_sum     = s
            best_centers = cand_centers
            best_radii   = cand_radii

    return best_centers, best_radii
=======
    for t in range(iters):
        # decaying step size
        alpha = initial_alpha * (1 - t / iters)
        cand_centers = best_centers.copy()

        # With 20% probability, perturb multiple centers simultaneously
        if rng.uniform() < 0.2:
            count = rng.integers(2, 5)  # perturb 2 to 4 centers
            indices = rng.choice(n, size=count, replace=False)
            for i in indices:
                delta = rng.uniform(-alpha, alpha, size=2)
                cand_centers[i] += delta
                cand_centers[i] = np.clip(cand_centers[i], margin, 1 - margin)
        else:
            i = int(rng.integers(n))
            delta = rng.uniform(-alpha, alpha, size=2)
            cand_centers[i] += delta
            cand_centers[i] = np.clip(cand_centers[i], margin, 1 - margin)

        # recompute radii & evaluate
        cand_radii = compute_max_radii(cand_centers)
        s = cand_radii.sum()
        if s > best_sum:
            best_sum     = s
            best_centers = cand_centers
            best_radii   = cand_radii

    # --- Physics-inspired relaxation refinement ---
    best_centers = physics_relaxation(best_centers, best_radii, steps=50, margin=margin)
    best_radii = compute_max_radii(best_centers)
    return best_centers, best_radii
>>>>>>> REPLACE

</DIFF>

<DIFF>
<<<<<<< SEARCH

def compute_max_radii(centers):
    """
    Given circle centers, compute the maximal non-overlapping radii
    within the unit square by iteratively enforcing border and pairwise constraints.
    """
    n = centers.shape[0]
    radii = np.minimum.reduce([
        centers[:,0],            # distance to left
        centers[:,1],            # distance to bottom
        1 - centers[:,0],        # right
        1 - centers[:,1]         # top
    ])

    # Iterative refinement to maximize radii under constraints
    for _ in range(10):  # fixed number of iterations for convergence
        changed = False
        for i in range(n):
            for j in range(i+1, n):
                d = np.hypot(*(centers[i] - centers[j]))
                if d <= 0:
                    # coincident centers — collapse both
                    if radii[i] != 0.0 or radii[j] != 0.0:
                        radii[i] = radii[j] = 0.0
                        changed = True
                else:
                    ri, rj = radii[i], radii[j]
                    if ri + rj > d:
                        scale = d / (ri + rj)
                        new_ri = ri * scale
                        new_rj = rj * scale
                        if new_ri < ri or new_rj < rj:
                            radii[i] = new_ri
                            radii[j] = new_rj
                            changed = True
        if not changed:
            break
    return radii

# EVOLVE-BLOCK-END
=======
def physics_relaxation(centers, radii, steps=50, margin=0.02):
    """
    Physics-inspired repulsive force refinement of circle centers.
    Args:
        centers: (n,2) array of current centers
        radii:   (n,) array of current radii
        steps:   number of force relaxation steps
        margin:  margin from square boundary
    Returns:
        refined_centers: (n,2) array
    """
    n = centers.shape[0]
    centers = centers.copy()
    for _ in range(steps):
        forces = np.zeros_like(centers)
        # Pairwise repulsive forces for overlap or near-overlap
        for i in range(n):
            for j in range(i+1, n):
                d_vec = centers[j] - centers[i]
                dist = np.linalg.norm(d_vec)
                min_dist = radii[i] + radii[j] + 1e-6
                if dist < min_dist:
                    # Repulsive force proportional to overlap
                    if dist > 1e-8:
                        direction = d_vec / dist
                    else:
                        direction = np.random.uniform(-1,1,2)
                        direction /= np.linalg.norm(direction)
                    overlap = min_dist - dist
                    f = 0.2 * overlap * direction
                    forces[i] -= f
                    forces[j] += f
        # Boundary repulsion
        for i in range(n):
            x, y = centers[i]
            r = radii[i]
            # Left
            if x - r < margin:
                forces[i,0] += 0.2 * (margin - (x - r))
            # Right
            if x + r > 1 - margin:
                forces[i,0] -= 0.2 * ((x + r) - (1 - margin))
            # Bottom
            if y - r < margin:
                forces[i,1] += 0.2 * (margin - (y - r))
            # Top
            if y + r > 1 - margin:
                forces[i,1] -= 0.2 * ((y + r) - (1 - margin))
        # Update positions
        centers += 0.15 * forces
        # Keep in margins
        centers = np.clip(centers, margin, 1 - margin)
    return centers

def compute_max_radii(centers):
    """
    Given circle centers, compute the maximal non-overlapping radii
    within the unit square by iteratively enforcing border and pairwise constraints.
    """
    n = centers.shape[0]
    radii = np.minimum.reduce([
        centers[:,0],            # distance to left
        centers[:,1],            # distance to bottom
        1 - centers[:,0],        # right
        1 - centers[:,1]         # top
    ])

    # Iterative refinement to maximize radii under constraints
    for _ in range(10):  # fixed number of iterations for convergence
        changed = False
        for i in range(n):
            for j in range(i+1, n):
                d = np.hypot(*(centers[i] - centers[j]))
                if d <= 0:
                    # coincident centers — collapse both
                    if radii[i] != 0.0 or radii[j] != 0.0:
                        radii[i] = radii[j] = 0.0
                        changed = True
                else:
                    ri, rj = radii[i], radii[j]
                    if ri + rj > d:
                        scale = d / (ri + rj)
                        new_ri = ri * scale
                        new_rj = rj * scale
                        if new_ri < ri or new_rj < rj:
                            radii[i] = new_ri
                            radii[j] = new_rj
                            changed = True
        if not changed:
            break
    return radii

# EVOLVE-BLOCK-END
>>>>>>> REPLACE

</DIFF>