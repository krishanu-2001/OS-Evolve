--- a/original.py
+++ b/original.py
@@ -1,157 +1,204 @@
 # EVOLVE-BLOCK-START
-"""Constructor-based circle packing for n=26 circles"""
+"""Hybrid ring+hex constructor with force relaxation and annealing for n=26 circles"""
 
 import numpy as np
 
-
 def construct_packing():
     """
-    Construct a specific arrangement of 26 circles in a unit square
-    that attempts to maximize the sum of their radii.
-
+    Hybrid initialization: structured rings + hex grid fill,
+    followed by force-based relaxation and adaptive simulated annealing.
     Returns:
-        Tuple of (centers, radii, sum_of_radii)
-        centers: np.array of shape (26, 2) with (x, y) coordinates
-        radii: np.array of shape (26) with radius of each circle
-        sum_of_radii: Sum of all radii
-    """
-    # Initialize arrays for 26 circles
+        centers: np.array (26,2)
+        radii:   np.array (26,)
+    """
+    np.random.seed(42)
     n = 26
-    centers = np.zeros((n, 2))
-
-    # Place circles in a structured pattern
-    # This is a simple pattern - evolution will improve this
-
-    # First, place a large circle in the center
+
+    centers = np.zeros((n,2))
+    # 1. Place a central circle
     centers[0] = [0.5, 0.5]
-
-    # Place 8 circles around it in a ring
+    # 2. Place 8 in a main ring (radius chosen for good internal clearance, randomized)
+    main_ring_r = 0.29 + np.random.uniform(-0.02, 0.02)
     for i in range(8):
         angle = 2 * np.pi * i / 8
-        centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]
-
-    # Place 16 more circles in an outer ring
-    for i in range(16):
-        angle = 2 * np.pi * i / 16
-        centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]
-
-    # Additional positioning adjustment to make sure all circles
-    # are inside the square and don't overlap
-    # Clip to ensure everything is inside the unit square
-    centers = np.clip(centers, 0.01, 0.99)
-
-    # Compute maximum valid radii for this configuration
+        centers[i+1] = [0.5 + main_ring_r * np.cos(angle), 0.5 + main_ring_r * np.sin(angle)]
+
+    # 3. Place 4 in corners, ensure inside
+    corners = np.array([[0.05,0.05], [0.05,0.95], [0.95,0.05], [0.95,0.95]])
+    centers[9:13] = corners
+
+    # 4. The next 8: edge-centered (well-inside border)
+    edge_offset = 0.09
+    edges = np.array([
+        [edge_offset,0.5], [0.5,edge_offset], [1-edge_offset,0.5], [0.5,1-edge_offset],
+        [edge_offset,edge_offset],
+        [1-edge_offset,edge_offset],
+        [edge_offset,1-edge_offset],
+        [1-edge_offset,1-edge_offset]
+    ])
+    centers[13:21] = edges
+
+    # 5. Fill remaining positions (5 left) using a tightest-packed hex grid determination
+    used = 21
+    needed = n - used
+    hex_candidates = []
+    grid_m = 8
+    dx = 0.90/(grid_m-1)
+    dy = dx * np.sqrt(3)/2
+    for i in range(grid_m):
+        for j in range(grid_m):
+            x = 0.05 + j*dx + (i%2)*(dx/2)
+            y = 0.05 + i*dy
+            if 0.04 < x < 0.96 and 0.04 < y < 0.96:
+                hex_candidates.append([x,y])
+    hex_candidates = np.array(hex_candidates)
+    # Exclude close points to placed circles
+    dists = np.linalg.norm(hex_candidates[:,None,:] - centers[:used][None,:,:], axis=2).min(axis=1)
+    idx = np.argsort(-dists)[:needed]
+    centers[used:used+needed] = hex_candidates[idx]
+
+    # 6. Add slight random jitter to all points (from physics code idea)
+    centers += (np.random.rand(n,2) - 0.5)*0.018
+    centers = np.clip(centers, 0.015, 0.985)
+
+    # Step 2: Initial radii assignment
     radii = compute_max_radii(centers)
 
-    # Post-optimization: simulated annealing with adaptive schedule and local greedy repacking
+    # Step 3: Physics-inspired force-based overlap/border relaxation
+    alpha = 0.035
+    for it in range(400):
+        forces = np.zeros((n,2))
+        # Repulsion (overlap)
+        for i in range(n):
+            for j in range(i+1,n):
+                dxy = centers[i] - centers[j]
+                dist = np.hypot(dxy[0], dxy[1]) + 1e-9
+                allow = radii[i]+radii[j]
+                if dist < allow and dist > 1e-10:
+                    # push away nearly proportionally to overlap
+                    overlap = (allow - dist) / (dist+1e-12)
+                    f = dxy * overlap * 0.5
+                    forces[i] += f
+                    forces[j] -= f
+        # Border corrective
+        margin = 0.001
+        for i in range(n):
+            x,y = centers[i]
+            r = radii[i]
+            # left/right
+            if x - r < 0:
+                forces[i,0] += (r - x + margin)
+            if x + r > 1:
+                forces[i,0] -= (x + r - 1 + margin)
+            if y - r < 0:
+                forces[i,1] += (r - y + margin)
+            if y + r > 1:
+                forces[i,1] -= (y + r - 1 + margin)
+        # Update
+        centers += alpha * forces
+        centers = np.clip(centers, 0.01, 0.99)
+        # Relax radii & decay step
+        radii = compute_max_radii(centers)
+        alpha *= 0.992 if it < 250 else 0.998
+
+    # Step 4: Simulated annealing with adaptive temperature and forced multi-point wiggles
     best_centers = centers.copy()
     best_radii = radii.copy()
     best_sum = np.sum(radii)
-    current_centers = centers.copy()
-    current_sum = best_sum
-    T0 = 0.01
-    T = T0
-    cooling_rate = 0.995
-    no_improve = 0
-    np.random.seed(1)
-    for it in range(1000):
-        # occasional multi-circle moves
-        if it % 100 == 0:
-            k = np.random.randint(2, 5)  # move 2-4 circles
+    T0 = 0.0025
+    temp = T0
+    stagnation = 0
+    for k in range(1500):
+        # select random 1 or 2 circles to jitter (diversity mutator)
+        kchg = 1 if np.random.rand() < 0.75 else 2
+        idxs = np.random.choice(n,kchg,replace=False)
+        old_pos = centers[idxs].copy()
+        delta = (np.random.randn(kchg,2)) * (0.008 * temp/(T0+1e-9))
+        centers[idxs] = np.clip(centers[idxs]+delta, 0.01, 0.99)
+        radii_tmp = compute_max_radii(centers)
+        sum_new = np.sum(radii_tmp)
+        dE = sum_new - best_sum
+        if dE > 0 or np.random.rand() < np.exp(dE/(temp+1e-12)):
+            if dE > 1e-8:
+                best_sum = sum_new
+                best_radii = radii_tmp.copy()
+                best_centers = centers.copy()
+                stagnation = 0
+            else:
+                stagnation += 1
         else:
-            k = np.random.randint(1, 3)  # move 1-2 circles
-        idxs = np.random.choice(n, k, replace=False)
-        scale = 0.05 * (1 - it / 1000)
-        trial = current_centers.copy()
-        trial[idxs] += np.random.randn(k, 2) * scale
-        trial = np.clip(trial, 0.01, 0.99)
-        trial_radii = compute_max_radii(trial)
-        s = np.sum(trial_radii)
-        dE = s - current_sum
-        # Metropolis acceptance
-        if dE > 0 or np.random.rand() < np.exp(dE / T):
-            current_centers = trial
-            current_sum = s
-            if s > best_sum:
-                best_sum = s
-                best_centers = trial.copy()
-                best_radii = trial_radii.copy()
-                no_improve = 0
-            else:
-                no_improve += 1
+            centers[idxs] = old_pos
+            stagnation += 1
+        # Adaptive cooling/heating
+        if stagnation > 60:
+            temp = min(T0, temp*1.2)
+            stagnation = 0
         else:
-            no_improve += 1
-        # adaptive temperature adjustment
-        if no_improve > 50:
-            T *= 1.05
-            no_improve = 0
-        else:
-            T *= cooling_rate
-    # Local greedy repacking sweep for fine detail
-    for i in range(n):
-        orig_pos = best_centers[i].copy()
-        for step in [0.01, 0.005, 0.001]:
-            for dx, dy in [(step,0),(-step,0),(0,step),(0,-step)]:
-                cand_centers = best_centers.copy()
-                cand_centers[i] = np.clip(orig_pos + np.array([dx, dy]), 0.01, 0.99)
-                cand_radii = compute_max_radii(cand_centers)
-                cand_sum = np.sum(cand_radii)
-                if cand_sum > best_sum:
-                    best_sum = cand_sum
-                    best_centers = cand_centers.copy()
-                    best_radii = cand_radii.copy()
-                    orig_pos = best_centers[i]
-        best_centers[i] = orig_pos
+            temp = max(T0*0.15, temp*0.997)
     centers, radii = best_centers, best_radii
+    # Stage 5: local greedy repacking sweep to further improve individual radii
+    def _greedy_repack_stage(c, samples=150):
+        n = c.shape[0]
+        for i in range(n):
+            # current radii and other circles
+            radii_all = compute_max_radii(c)
+            others = np.delete(c, i, axis=0)
+            other_rs = np.delete(radii_all, i)
+            best_p = c[i].copy()
+            best_r = radii_all[i]
+            # generate candidate points: local jitter and some global samples
+            local_pts = best_p + np.random.randn(samples, 2) * (best_r * 0.4 + 1e-6)
+            global_pts = np.random.rand(samples, 2) * 0.98 + 0.01
+            pts = np.vstack((local_pts, global_pts))
+            pts = np.clip(pts, 0.01, 0.99)
+            for p in pts:
+                # wall constraint
+                r_new = min(p[0], 1-p[0], p[1], 1-p[1])
+                # overlap constraint
+                if others.size > 0:
+                    d = np.linalg.norm(others - p, axis=1) - other_rs
+                    r_new = min(r_new, d.min())
+                if r_new > best_r:
+                    best_r = r_new
+                    best_p = p
+            c[i] = best_p
+        return c
+    centers = _greedy_repack_stage(centers)
+    radii = compute_max_radii(centers)
     return centers, radii
-
 
 def compute_max_radii(centers):
     """
     Compute the maximum possible radii for each circle position
     such that they don't overlap and stay within the unit square.
-
-    Args:
-        centers: np.array of shape (n, 2) with (x, y) coordinates
-
-    Returns:
-        np.array of shape (n) with radius of each circle
+    Uses a robust pairwise relaxation (many more iterations than parent codes).
     """
     n = centers.shape[0]
-    radii = np.ones(n)
-
-    # First, limit by distance to square borders
-    for i in range(n):
-        x, y = centers[i]
-        # Distance to borders
-        radii[i] = min(x, y, 1 - x, 1 - y)
-
-    # Then, limit by distance to other circles: iterate until convergence
-    for _ in range(20):
-        changed = False
-        for i in range(n):
-            for j in range(i + 1, n):
-                d = np.linalg.norm(centers[i] - centers[j])
-                if radii[i] + radii[j] > d:
-                    scale = d / (radii[i] + radii[j] + 1e-12)
+    xs, ys = centers[:,0], centers[:,1]
+    radii = np.minimum.reduce([xs, ys, 1-xs, 1-ys])
+    for iter in range(70):
+        max_change = 0.0
+        for i in range(n):
+            for j in range(i+1,n):
+                dxy = centers[i] - centers[j]
+                dist = np.hypot(dxy[0], dxy[1])
+                max_sum = radii[i] + radii[j]
+                if max_sum > dist and dist > 1e-10:
+                    scale = dist / (max_sum+1e-12)
                     old_i, old_j = radii[i], radii[j]
                     radii[i] *= scale
                     radii[j] *= scale
-                    if abs(radii[i] - old_i) > 1e-8 or abs(radii[j] - old_j) > 1e-8:
-                        changed = True
-        if not changed:
+                    max_change = max(max_change, abs(radii[i]-old_i), abs(radii[j]-old_j))
+        if max_change < 1e-7:
             break
-
     return radii
-
-
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii