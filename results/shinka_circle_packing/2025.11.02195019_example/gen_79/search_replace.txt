<NAME>
adaptive_multi_circle_perturbation_and_local_repack
</NAME>

<DESCRIPTION>
Introduce a periodic multi-circle perturbation step during the hill-climbing phase to escape local minima more effectively. Additionally, add a local greedy repacking sweep after the hill-climbing to fine-tune each circle's position by sampling nearby candidate positions to maximize its radius locally. This hybrid approach leverages both global exploration and local exploitation, which is known to improve packing density in circle packing problems.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # Adaptive hill-climbing parameters
    iters = 6000
    initial_alpha = dx * 0.5
    rng = np.random.default_rng(42)

    for t in range(iters):
        alpha = initial_alpha * (1 - t / iters)
        cand_centers = best_centers.copy()

        # 20% chance to perturb multiple centers simultaneously
        if rng.uniform() < 0.2:
            count = rng.integers(2, 5)  # perturb 2 to 4 centers
            indices = rng.choice(n, size=count, replace=False)
            for i in indices:
                delta = rng.uniform(-alpha, alpha, size=2)
                cand_centers[i] += delta
                cand_centers[i] = np.clip(cand_centers[i], margin, 1 - margin)
        else:
            i = int(rng.integers(n))
            delta = rng.uniform(-alpha, alpha, size=2)
            cand_centers[i] += delta
            cand_centers[i] = np.clip(cand_centers[i], margin, 1 - margin)

        cand_radii = compute_max_radii(cand_centers)
        s = cand_radii.sum()
        if s > best_sum:
            best_sum = s
            best_centers = cand_centers
            best_radii = cand_radii

    # Physics-inspired relaxation refinement
    best_centers = physics_relaxation(best_centers, best_radii, steps=60, margin=margin)
    best_radii = compute_max_radii(best_centers)
    return best_centers, best_radii
=======
    # Adaptive hill-climbing parameters
    iters = 6000
    initial_alpha = dx * 0.5
    rng = np.random.default_rng(42)

    for t in range(iters):
        alpha = initial_alpha * (1 - t / iters)
        cand_centers = best_centers.copy()

        # Every 200 iterations, do a multi-circle perturbation to escape local minima
        if t % 200 == 0:
            count = rng.integers(3, 6)  # perturb 3 to 5 centers
            indices = rng.choice(n, size=count, replace=False)
            for i in indices:
                delta = rng.uniform(-alpha*1.5, alpha*1.5, size=2)
                cand_centers[i] += delta
                cand_centers[i] = np.clip(cand_centers[i], margin, 1 - margin)
        else:
            # 20% chance to perturb multiple centers simultaneously
            if rng.uniform() < 0.2:
                count = rng.integers(2, 5)  # perturb 2 to 4 centers
                indices = rng.choice(n, size=count, replace=False)
                for i in indices:
                    delta = rng.uniform(-alpha, alpha, size=2)
                    cand_centers[i] += delta
                    cand_centers[i] = np.clip(cand_centers[i], margin, 1 - margin)
            else:
                i = int(rng.integers(n))
                delta = rng.uniform(-alpha, alpha, size=2)
                cand_centers[i] += delta
                cand_centers[i] = np.clip(cand_centers[i], margin, 1 - margin)

        cand_radii = compute_max_radii(cand_centers)
        s = cand_radii.sum()
        if s > best_sum:
            best_sum = s
            best_centers = cand_centers
            best_radii = cand_radii

    # Local greedy repacking sweep to fine-tune each circle's position
    repack_radius = dx * 0.3
    repack_samples = 40
    for i in range(n):
        others = np.delete(best_centers, i, axis=0)
        best_pos = best_centers[i].copy()
        best_r = best_radii[i]
        # Sample candidate positions around current position
        candidates = best_pos + (rng.random((repack_samples, 2)) * 2 - 1) * repack_radius
        candidates = np.clip(candidates, margin, 1 - margin)
        for c_pos in candidates:
            border_r = min(c_pos[0], c_pos[1], 1 - c_pos[0], 1 - c_pos[1])
            dmin = np.min(np.linalg.norm(others - c_pos, axis=1))
            cand_r = min(border_r, dmin)
            if cand_r > best_r:
                best_r = cand_r
                best_pos = c_pos
        best_centers[i] = best_pos
    best_radii = compute_max_radii(best_centers)

    # Physics-inspired relaxation refinement
    best_centers = physics_relaxation(best_centers, best_radii, steps=60, margin=margin)
    best_radii = compute_max_radii(best_centers)
    return best_centers, best_radii
>>>>>>> REPLACE

</DIFF>