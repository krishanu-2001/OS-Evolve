--- a/original.py
+++ b/original.py
@@ -1,173 +1,273 @@
 # EVOLVE-BLOCK-START
 import numpy as np
-import math
-
-def greedy_initial(n, samples=8000, seed=0):
-    """
-    Sequentially place n circles.
-    At each step, sample 'samples' random points and pick the one
-    with the largest feasible radius given existing circles.
-    Additionally, for k>0, add a local sampling around existing circles
-    to better fill gaps and edges.
-    """
-    rnd = np.random.RandomState(seed)
+
+def construct_packing():
+    """
+    Top-level: runs a modular, staged optimization scheduler to find a high-sum-of-radii packing of 26 circles in [0, 1]^2.
+    Returns: (centers, radii)
+    """
+    n = 26
+    margin = 0.02
+    rng = np.random.default_rng(202406)
+    # Candidate hexagon layouts to explore structural variety
+    layouts = [
+        [6,5,6,5,4],
+        [5,6,5,6,4],
+        [6,6,5,5,4],
+        [5,5,6,6,4],
+        [6,5,5,6,4]
+    ]
+    # Stage configuration
+    num_candidates = 15
+    hill_iters = 1600
+    anneal_iters = 700
+    physics_steps = 30
+    polish_iters = 230
+
+    # ====== Stage 1: Candidate set expansion ======
+    candidate_centers = []
+    candidate_sums = []
+    for _ in range(num_candidates):
+        mode = rng.random()
+        if mode < 0.6:
+            row_counts = layouts[rng.integers(len(layouts))]
+            centers = _hex_layout(row_counts, n, margin, rng)
+        elif mode < 0.8:
+            centers = rng.uniform(margin, 1-margin, size=(n,2))
+        else:
+            centers = _greedy_local_sampling_init(n, margin, rng)
+        radii = compute_max_radii(centers, margin)
+        candidate_centers.append(centers)
+        candidate_sums.append(radii.sum())
+    # Take the best initial candidate
+    idx = np.argmax(candidate_sums)
+    centers = candidate_centers[idx]
+
+    # ====== Stage 2: Hill climbing (decayed step, multi-center perturb) ======
+    centers = _hill_climb_stage(centers, hill_iters, margin, layouts, rng)
+
+    # ====== Stage 3: Physics-inspired relaxation ======
+    centers = _physics_stage(centers, physics_steps, margin, rng)
+
+    # ====== Stage 4: Simulated Annealing ======
+    centers = _anneal_stage(centers, anneal_iters, margin, layouts, rng)
+
+    # ====== Stage 5: Final local polishing (mini-annealing, high temperature, small step) ======
+    centers = _final_polish_stage(centers, polish_iters, margin, layouts, rng)
+
+    radii = compute_max_radii(centers, margin)
+    return centers, radii
+
+# --- Stage helpers ---
+
+def _hex_layout(row_counts, n, margin, rng):
+    max_cols = max(row_counts)
+    dx = (1 - 2*margin) / max_cols
+    h  = dx * np.sqrt(3) / 2
+    centers = np.zeros((n, 2))
+    idx = 0
+    for rid, cnt in enumerate(row_counts):
+        x0 = margin + (max_cols - cnt) * dx / 2
+        y = margin + rid*h
+        for c in range(cnt):
+            centers[idx] = [x0 + c*dx, y]
+            idx += 1
+    # Center the pattern vertically if <1 in height
+    height = h * (len(row_counts) - 1)
+    offset = (1 - 2*margin - height) * 0.5
+    if offset > 0:
+        centers[:,1] += offset
+    # Tiny jitter to avoid degenerate initial overlaps
+    centers += rng.normal(0, 0.0002, centers.shape)
+    return centers
+
+def _hill_climb_stage(centers, iters, margin, layouts, rng):
+    n = centers.shape[0]
+    dx = (1 - 2*margin) / max(map(len, layouts))
+    alpha0 = dx * 0.55
+    best_c = centers.copy()
+    best_r = compute_max_radii(best_c, margin)
+    best_s = best_r.sum()
+    for t in range(iters):
+        alpha = alpha0 * (1 - t / iters)
+        cand_c = best_c.copy()
+        prob = 0.47 * (1 - t/iters) + 0.11
+        if rng.random() < prob:
+            k = rng.integers(2, 6)
+            idxs = rng.choice(n, size=k, replace=False)
+            deltas = rng.uniform(-alpha, alpha, size=(k,2))
+            cand_c[idxs] += deltas
+        else:
+            i = int(rng.integers(n))
+            cand_c[i] += rng.uniform(-alpha, alpha, 2)
+        np.clip(cand_c, margin, 1-margin, out=cand_c)
+        cand_r = compute_max_radii(cand_c, margin)
+        s = cand_r.sum()
+        if s > best_s + 1e-12:
+            best_s, best_c, best_r = s, cand_c, cand_r
+    return best_c
+
+def _physics_stage(centers, steps, margin, rng):
+    n = centers.shape[0]
+    c = centers.copy()
+    r = compute_max_radii(c, margin)
+    for _ in range(steps):
+        forces = np.zeros_like(c)
+        # Pairwise repulsion (if overlap)
+        for i in range(n):
+            for j in range(i+1, n):
+                dv = c[j] - c[i]
+                dist = np.linalg.norm(dv)
+                min_d = r[i] + r[j] + 1e-6
+                if dist < min_d:
+                    dirv = dv/dist if dist > 1e-8 else rng.normal(size=2)
+                    overlap = min_d - dist
+                    f = 0.19 * overlap * dirv
+                    forces[i] -= f
+                    forces[j] += f
+        # Boundary repulsion
+        for i in range(n):
+            x, y, ri = c[i,0], c[i,1], r[i]
+            if x - ri < margin:
+                forces[i, 0] += 0.22 * (margin - (x-ri))
+            if x + ri > 1-margin:
+                forces[i, 0] -= 0.22 * ((x+ri)-(1-margin))
+            if y - ri < margin:
+                forces[i, 1] += 0.22 * (margin - (y-ri))
+            if y + ri > 1-margin:
+                forces[i, 1] -= 0.22 * ((y+ri)-(1-margin))
+        c += 0.14 * forces
+        np.clip(c, margin, 1-margin, out=c)
+        r = compute_max_radii(c, margin)
+    return c
+
+def _anneal_stage(centers, iters, margin, layouts, rng):
+    n = centers.shape[0]
+    c = centers.copy()
+    r = compute_max_radii(c, margin)
+    e = r.sum()
+    dx = (1 - 2*margin) / max(map(len, layouts))
+    T0, T1 = 1.1e-2, 2.2e-4
+    for k in range(iters):
+        T = T0 * ((1-k/iters) + (T1/T0)*(k/iters))
+        i = int(rng.integers(n))
+        cand = c.copy()
+        step = dx * (0.69 + 0.36*np.sin(k/41.9))  # small periodic vib
+        delta = rng.uniform(-step, step, 2) * (1 - k/iters)
+        cand[i] += delta
+        np.clip(cand, margin, 1-margin, out=cand)
+        cand_r = compute_max_radii(cand, margin)
+        cand_e = cand_r.sum()
+        dE = cand_e - e
+        if dE > 0 or rng.random() < np.exp(dE / (T+1e-16)):
+            c, r, e = cand, cand_r, cand_e
+    return c
+
+def _final_polish_stage(centers, iters, margin, layouts, rng):
+    # Mini-annealing: higher T0, decayed fast, single or paired center moves for late local optima escape
+    n = centers.shape[0]
+    c = centers.copy()
+    r = compute_max_radii(c, margin)
+    e = r.sum()
+    dx = (1 - 2*margin) / max(map(len, layouts))
+    T0, T1 = 5.5e-3, 1e-5
+    for k in range(iters):
+        T = T0 * ((1-k/iters) + (T1/T0)*(k/iters))
+        cand = c.copy()
+        if rng.random() < 0.16:
+            # paired move
+            idxs = rng.choice(n, size=2, replace=False)
+            delta = rng.uniform(-dx, dx, (2,2)) * (1-k/iters)
+            cand[idxs] += delta
+        else:
+            i = int(rng.integers(n))
+            delta = rng.uniform(-dx, dx, 2) * (1-k/iters)
+            cand[i] += delta
+        np.clip(cand, margin, 1-margin, out=cand)
+        cand_r = compute_max_radii(cand, margin)
+        cand_e = cand_r.sum()
+        dE = cand_e - e
+        if dE > 0 or rng.random() < np.exp(dE / (T+1e-16)):
+            c, r, e = cand, cand_r, cand_e
+    return c
+
+def _greedy_local_sampling_init(n, margin, rng, global_samples=1200, local_samples=300):
+    """
+    Greedy sequential placement: each circle placed to maximize its feasible radius,
+    sampling both globally and near existing circles' peripheries.
+    """
     centers = []
     radii = []
     for k in range(n):
-        pts = rnd.rand(samples,2)
-        # Add local samples near existing circles to fill gaps
+        pts = []
+        # global random samples
+        pts.append(rng.uniform(margin, 1-margin, size=(global_samples, 2)))
         if k > 0:
-            arr_centers = np.array(centers)
-            arr_radii = np.array(radii)
-            local_pts = []
-            for c, r in zip(arr_centers, arr_radii):
-                # sample points in annulus around circle edge
-                angles = rnd.rand(20)*2*np.pi
-                radii_local = r + rnd.rand(20)*0.05
-                xs = c[0] + radii_local * np.cos(angles)
-                ys = c[1] + radii_local * np.sin(angles)
-                pts_local = np.stack([xs, ys], axis=1)
-                # keep only points inside unit square
-                pts_local = pts_local[(pts_local[:,0]>=0) & (pts_local[:,0]<=1) & (pts_local[:,1]>=0) & (pts_local[:,1]<=1)]
-                local_pts.append(pts_local)
-            if local_pts:
-                pts = np.vstack([pts] + local_pts)
+            arr = np.array(centers)
+            arr_r = np.array(radii)
+            # For each existing circle, sample points near its boundary
+            samples_per_circle = max(local_samples // k, 5)
+            for ci, ri in zip(arr, arr_r):
+                angles = rng.uniform(0, 2*np.pi, samples_per_circle)
+                offset = ri + rng.uniform(0.01, 0.07, size=angles.shape)
+                local_pts = ci + np.stack([np.cos(angles), np.sin(angles)], axis=1) * offset[:,None]
+                local_pts = np.clip(local_pts, margin, 1-margin)
+                pts.append(local_pts)
+        pts = np.concatenate(pts, axis=0)
         best_r = -1.0
         best_p = None
         if k == 0:
-            # for first circle just pick the best by walls
             xs = pts[:,0]; ys = pts[:,1]
-            rs = np.minimum.reduce([xs, ys, 1-xs, 1-ys])
+            rs = np.minimum.reduce([xs-margin, ys-margin, 1-margin-xs, 1-margin-ys])
             idx = np.argmax(rs)
             best_r = rs[idx]; best_p = pts[idx]
         else:
-            arr_centers = np.array(centers)
-            arr_radii = np.array(radii)
+            arr = np.array(centers)
+            arr_r = np.array(radii)
             for p in pts:
-                # radius limited by walls
-                r = min(p[0], p[1], 1-p[0], 1-p[1])
-                # limit by existing circles
-                d = np.linalg.norm(arr_centers - p, axis=1) - arr_radii
+                r = np.min([p[0]-margin, p[1]-margin, 1-margin-p[0], 1-margin-p[1]])
+                d = np.linalg.norm(arr - p, axis=1) - arr_r
                 r = min(r, d.min())
                 if r > best_r:
                     best_r = r; best_p = p
         centers.append(best_p)
         radii.append(max(best_r, 1e-6))
-    return np.array(centers), np.array(radii)
-
-def compute_radius_at(i, centers, radii):
-    """
-    Given center i, compute its maximal radius not overlapping others or walls.
-    """
-    x,y = centers[i]
-    # wall limit
-    r = min(x, y, 1-x, 1-y)
-    if len(centers) > 1:
-        # exclude self
-        others = np.delete(centers, i, axis=0)
-        rads  = np.delete(radii, i)
-        d = np.linalg.norm(others - centers[i], axis=1) - rads
-        r = min(r, d.min())
-    return max(r, 0.0)
-
-def simulated_annealing(centers, radii, iters=12000, T0=0.1, Tend=1e-4, seed=1):
-    """
-    Refine the placement by simulated annealing: perturb one or multiple circles at a time,
-    recompute their max radii, and accept moves that improve total radius or
-    stochastically based on temperature.
-    """
-    rnd = np.random.RandomState(seed)
-    n = centers.shape[0]
-    best_centers = centers.copy()
-    best_radii  = radii.copy()
-    best_sum = radii.sum()
-
-    curr_centers = centers.copy()
-    curr_radii = radii.copy()
-    curr_sum = best_sum
-    T = T0
-    decay = (Tend/T0)**(1.0/iters)
-
-    multi_prob = 0.05
-    multi_count = 3
-    step_scale = 0.02
-
-    for it in range(iters):
-        if rnd.rand() < multi_prob:
-            # multi-circle perturbation
-            idxs = rnd.choice(n, multi_count, replace=False)
-            old_ps = curr_centers[idxs].copy()
-            old_rs = curr_radii[idxs].copy()
-            steps = rnd.randn(multi_count, 2) * step_scale
-            new_ps = old_ps + steps
-            new_ps = np.clip(new_ps, 0.0, 1.0)
-            curr_centers[idxs] = new_ps
-            new_rs = np.array([compute_radius_at(i, curr_centers, curr_radii) for i in idxs])
-            if (new_rs > 1e-8).all():
-                new_sum = curr_sum - old_rs.sum() + new_rs.sum()
-                delta = new_sum - curr_sum
-                if delta >= 0 or rnd.rand() < math.exp(delta / T):
-                    curr_radii[idxs] = new_rs
-                    curr_sum = new_sum
-                    if curr_sum > best_sum:
-                        best_sum = curr_sum
-                        best_centers[:] = curr_centers
-                        best_radii[:] = curr_radii
+    return np.array(centers)
+
+def compute_max_radii(centers, margin=0.0):
+    """
+    Compute the maximal radii for given (n,2) centers, no-overlap and margin.
+    Refined: Iterates to full convergence not just fixed passes.
+    """
+    n = centers.shape[0]
+    radii = np.minimum.reduce([centers[:,0]-margin, centers[:,1]-margin,
+                               1-margin-centers[:,0], 1-margin-centers[:,1]])
+    radii = np.clip(radii, 0, 1)
+    for _ in range(100):
+        old = radii.copy()
+        for i in range(n):
+            for j in range(i+1, n):
+                d = np.linalg.norm(centers[i] - centers[j])
+                if d <= 1e-10:
+                    if radii[i]>0 or radii[j]>0:
+                        radii[i]=radii[j]=0.0
                 else:
-                    curr_centers[idxs] = old_ps
-            else:
-                curr_centers[idxs] = old_ps
-        else:
-            # single-circle perturbation
-            i = rnd.randint(n)
-            old_p = curr_centers[i].copy()
-            old_r = curr_radii[i]
-            step = rnd.randn(2) * step_scale
-            new_p = old_p + step
-            new_p = np.clip(new_p, 0.0, 1.0)
-            curr_centers[i] = new_p
-            new_r = compute_radius_at(i, curr_centers, curr_radii)
-            if new_r <= 1e-8:
-                curr_centers[i] = old_p
-            else:
-                new_sum = curr_sum - old_r + new_r
-                delta = new_sum - curr_sum
-                if delta >= 0 or rnd.rand() < math.exp(delta / T):
-                    curr_radii[i] = new_r
-                    curr_sum = new_sum
-                    if curr_sum > best_sum:
-                        best_sum = curr_sum
-                        best_centers[:] = curr_centers
-                        best_radii[:] = curr_radii
-                else:
-                    curr_centers[i] = old_p
-        T *= decay
-
-    return best_centers, best_radii
-
-def construct_packing():
-    """
-    Build and optimize 26-circle packing via greedy initialization
-    followed by simulated annealing refinement.
-    """
-    n = 26
-    # Phase 1: greedy placement
-    centers, radii = greedy_initial(n, samples=8000, seed=42)
-    # Phase 2: simulated annealing
-    centers, radii = simulated_annealing(centers, radii,
-                                         iters=15000,
-                                         T0=0.05,
-                                         Tend=1e-5,
-                                         seed=999)
-    return centers, radii
+                    ri, rj = radii[i], radii[j]
+                    if ri + rj > d:
+                        scale = d / (ri + rj)
+                        radii[i] *= scale
+                        radii[j] *= scale
+        if np.max(np.abs(radii-old)) < 1e-7:
+            break
+    return radii
 
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii