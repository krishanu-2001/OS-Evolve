--- a/original.py
+++ b/original.py
@@ -1,227 +1,284 @@
 # EVOLVE-BLOCK-START
 import numpy as np
 import math
 
-def multi_scale_greedy_initial(n, base_samples=6000, local_samples=30, seed=0):
+def construct_packing():
     """
-    Multi-scale greedy initialization:
-    - At each placement step, sample many random points globally.
-    - Additionally, sample multiple local points around existing circles'
-      edges at different scales to fill gaps.
-    - Choose the candidate point with the largest feasible radius.
+    Construct 26-circle packing by hybrid pipeline:
+    diversified initialization, adaptive simulated annealing,
+    and final physics relaxation with radius optimization.
     """
-    rnd = np.random.RandomState(seed)
-    centers = []
-    radii = []
-    for k in range(n):
-        # Global random samples
-        pts = rnd.rand(base_samples, 2)
-        # Local multi-scale samples around placed circles
-        if k > 0:
-            arr_centers = np.array(centers)
-            arr_radii = np.array(radii)
-            local_pts_list = []
-            scales = [0.015, 0.035, 0.07]  # multiple scales for gap filling
-            for c, r in zip(arr_centers, arr_radii):
-                for scale in scales:
-                    angles = rnd.rand(local_samples)*2*np.pi
-                    radii_local = r + scale + rnd.rand(local_samples)*scale*0.5
-                    xs = c[0] + radii_local * np.cos(angles)
-                    ys = c[1] + radii_local * np.sin(angles)
-                    pts_local = np.stack([xs, ys], axis=1)
-                    # Keep only points inside unit square
-                    pts_local = pts_local[(pts_local[:,0]>=0) & (pts_local[:,0]<=1) & (pts_local[:,1]>=0) & (pts_local[:,1]<=1)]
-                    local_pts_list.append(pts_local)
-            if local_pts_list:
-                pts = np.vstack([pts] + local_pts_list)
-        best_r = -1.0
-        best_p = None
-        if k == 0:
-            # For first circle pick max radius limited by borders
-            xs = pts[:,0]; ys = pts[:,1]
-            rs = np.minimum.reduce([xs, ys, 1-xs, 1-ys])
-            idx = np.argmax(rs)
-            best_r = rs[idx]; best_p = pts[idx]
+    pipeline = HybridPackingPipeline(n=26, margin=0.02, seed=1234)
+    centers, radii = pipeline.run()
+    return centers, radii
+
+class HybridPackingPipeline:
+    def __init__(self, n, margin, seed):
+        self.n = n
+        self.margin = margin
+        self.rng = np.random.default_rng(seed)
+        # Hex row layouts summing to n, balancing rows
+        self.layouts = [
+            [6,5,6,5,4],
+            [5,6,5,6,4],
+            [6,6,5,5,4],
+            [5,5,6,6,4],
+            [6,5,5,6,4]
+        ]
+        # Parameters
+        self.num_restarts = 15
+        self.hill_iters = 1500
+        self.anneal_iters = 15000
+        self.physics_steps = 40
+        self.step_scale = 0.018
+        self.multi_prob = 0.07
+        self.multi_count = 3
+
+    def run(self):
+        best_sum = -np.inf
+        best_centers = None
+        best_radii = None
+        for _ in range(self.num_restarts):
+            c = self._initialize()
+            c = self._hill_climb(c)
+            c = self._adaptive_simulated_annealing(c)
+            c = self._physics_relax(c)
+            r = compute_max_radii(c)
+            s = r.sum()
+            if s > best_sum:
+                best_sum, best_centers, best_radii = s, c.copy(), r.copy()
+        return best_centers, best_radii
+
+    def _initialize(self):
+        p = self.rng.random()
+        # 40% hex layout, 25% corner-edge layout, 35% random uniform
+        if p < 0.4:
+            layout = self.rng.choice(self.layouts)
+            return self._hex_layout(layout)
+        elif p < 0.65:
+            return self._corner_edge_layout()
         else:
-            arr_centers = np.array(centers)
-            arr_radii = np.array(radii)
-            for p in pts:
-                # radius limited by borders
-                r = min(p[0], p[1], 1-p[0], 1-p[1])
-                # limit by existing circles
-                d = np.linalg.norm(arr_centers - p, axis=1) - arr_radii
-                r = min(r, d.min())
-                if r > best_r:
-                    best_r = r; best_p = p
-        centers.append(best_p)
-        radii.append(max(best_r, 1e-8))
-    return np.array(centers), np.array(radii)
+            return self.rng.uniform(self.margin, 1-self.margin, size=(self.n,2))
+
+    def _hex_layout(self, rows):
+        max_cols = max(rows)
+        dx = (1 - 2*self.margin) / max_cols
+        height = dx * np.sqrt(3) / 2
+        centers = np.zeros((self.n, 2))
+        idx = 0
+        for r, count in enumerate(rows):
+            x0 = self.margin + (max_cols - count)*dx/2
+            y = self.margin + r*height
+            for c in range(count):
+                centers[idx] = [x0 + c*dx, y]
+                idx += 1
+        return centers
+
+    def _corner_edge_layout(self):
+        centers = np.zeros((self.n,2))
+        m = self.margin + 0.01
+        corners = np.array([
+            [m,m],
+            [1-m,m],
+            [m,1-m],
+            [1-m,1-m],
+        ])
+        centers[:4] = corners
+        remaining = self.n - 4
+        per_edge = remaining // 4
+        extra = remaining % 4
+        idx = 4
+        # distribute along bottom edge, left to right
+        for i in range(per_edge + (1 if extra>0 else 0)):
+            t = (i+1)/(per_edge + (1 if extra>0 else 0) + 1)
+            centers[idx] = [m + t*(1-2*m), m]
+            idx +=1
+        # right edge, bottom to top
+        for i in range(per_edge + (1 if extra>1 else 0)):
+            t = (i+1)/(per_edge + (1 if extra>1 else 0) + 1)
+            centers[idx] = [1-m, m + t*(1-2*m)]
+            idx +=1
+        # top edge, right to left
+        for i in range(per_edge + (1 if extra>2 else 0)):
+            t = (i+1)/(per_edge + (1 if extra>2 else 0) + 1)
+            centers[idx] = [1-m - t*(1-2*m), 1-m]
+            idx +=1
+        # left edge, top to bottom
+        for i in range(per_edge):
+            t = (i+1)/(per_edge + 1)
+            if idx < self.n:
+                centers[idx] = [m, 1-m - t*(1-2*m)]
+                idx +=1
+        return centers
+
+    def _hill_climb(self, centers):
+        c = centers.copy()
+        r = compute_max_radii(c)
+        best_sum = r.sum()
+        best_c = c.copy()
+        alpha0 = ((1 - 2*self.margin) / max(map(len, self.layouts))) * 0.5
+        for t in range(self.hill_iters):
+            alpha = alpha0 * (1-t/self.hill_iters)
+            cand = best_c.copy()
+            prob_multi = 0.5 * (1 - t/self.hill_iters) + 0.1
+            if self.rng.random() < prob_multi:
+                k = self.rng.integers(2,5)
+                idxs = self.rng.choice(self.n, size=k, replace=False)
+                for i in idxs:
+                    cand[i] += self.rng.uniform(-alpha, alpha, 2)
+            else:
+                i = int(self.rng.integers(self.n))
+                cand[i] += self.rng.uniform(-alpha, alpha, 2)
+            np.clip(cand, self.margin, 1-self.margin, out=cand)
+            cr = compute_max_radii(cand)
+            s = cr.sum()
+            if s > best_sum:
+                best_sum = s
+                best_c = cand
+        return best_c
+
+    def _adaptive_simulated_annealing(self, centers):
+        c = centers.copy()
+        r = compute_max_radii(c)
+        e = r.sum()
+        T0, Tend = 0.07, 1e-5
+        iters = self.anneal_iters
+        T = T0
+        decay_base = (Tend / T0) ** (1.0 / iters)
+        stagnation = 0
+        stagnation_limit = 200
+        for it in range(iters):
+            # Adaptive cooling
+            if stagnation < stagnation_limit:
+                T = max(T * decay_base, Tend)
+            else:
+                T = max(T * (decay_base ** 3), Tend)
+
+            if self.rng.random() < self.multi_prob:
+                idxs = self.rng.choice(self.n, self.multi_count, replace=False)
+                old_ps = c[idxs].copy()
+                old_rs = compute_max_radii(c)[idxs].copy()
+                steps = self.rng.normal(0, self.step_scale, (self.multi_count, 2))
+                new_ps = old_ps + steps
+                new_ps = np.clip(new_ps, self.margin, 1-self.margin)
+                c[idxs] = new_ps
+                new_rs = np.array([compute_radius_at(i, c, compute_max_radii(c)) for i in idxs])
+                if (new_rs > 1e-8).all():
+                    new_sum = compute_max_radii(c).sum()
+                    delta = new_sum - e
+                    if delta >= 0 or self.rng.random() < math.exp(delta / T):
+                        r = compute_max_radii(c)
+                        e = new_sum
+                        stagnation = 0 if delta > 0 else stagnation+1
+                    else:
+                        c[idxs] = old_ps
+                        stagnation += 1
+                else:
+                    c[idxs] = old_ps
+                    stagnation += 1
+            else:
+                i = int(self.rng.integers(self.n))
+                old_p = c[i].copy()
+                old_r = compute_radius_at(i, c, compute_max_radii(c))
+                step = self.rng.normal(0, self.step_scale, 2)
+                new_p = old_p + step
+                new_p = np.clip(new_p, self.margin, 1-self.margin)
+                c[i] = new_p
+                new_r = compute_radius_at(i, c, compute_max_radii(c))
+                if new_r <= 1e-8:
+                    c[i] = old_p
+                    stagnation += 1
+                else:
+                    new_sum = compute_max_radii(c).sum()
+                    delta = new_sum - e
+                    if delta >= 0 or self.rng.random() < math.exp(delta / T):
+                        e = new_sum
+                        stagnation = 0 if delta > 0 else stagnation+1
+                    else:
+                        c[i] = old_p
+                        stagnation += 1
+        return c
+
+    def _physics_relax(self, centers):
+        c = centers.copy()
+        r = compute_max_radii(c)
+        for _ in range(self.physics_steps):
+            forces = np.zeros_like(c)
+            for i in range(self.n):
+                for j in range(i+1, self.n):
+                    dv = c[j] - c[i]
+                    dist = np.linalg.norm(dv)
+                    min_d = r[i] + r[j] + 1e-6
+                    if dist < min_d:
+                        dirv = dv/dist if dist>1e-8 else self.rng.normal(size=2)
+                        overlap = min_d - dist
+                        f = 0.25 * overlap * dirv
+                        forces[i] -= f
+                        forces[j] += f
+            for i in range(self.n):
+                x,y = c[i]
+                ri = r[i]
+                if x - ri < self.margin:
+                    forces[i,0] += 0.25*(self.margin - (x - ri))
+                if x + ri > 1 - self.margin:
+                    forces[i,0] -= 0.25*((x + ri) - (1 - self.margin))
+                if y - ri < self.margin:
+                    forces[i,1] += 0.25*(self.margin - (y - ri))
+                if y + ri > 1 - self.margin:
+                    forces[i,1] -= 0.25*((y + ri) - (1 - self.margin))
+            c += 0.12 * forces
+            np.clip(c, self.margin, 1-self.margin, out=c)
+            r = compute_max_radii(c)
+        return c
 
 def compute_radius_at(i, centers, radii):
-    """
-    Compute maximal radius for circle i given others fixed.
-    """
-    x,y = centers[i]
-    r = min(x, y, 1-x, 1-y)
+    # Deterministic max radius for circle i given fixed others
+    x, y = centers[i]
+    r = min(x - 0, y - 0, 1 - x, 1 - y)
     if len(centers) > 1:
         others = np.delete(centers, i, axis=0)
-        rads = np.delete(radii, i)
-        d = np.linalg.norm(others - centers[i], axis=1) - rads
-        r = min(r, d.min())
+        orads = np.delete(radii, i)
+        dists = np.linalg.norm(others - centers[i], axis=1) - orads
+        min_d = dists.min()
+        r = min(r, min_d)
     return max(r, 0.0)
 
-def adaptive_simulated_annealing(centers, radii, iters=18000, T0=0.07, Tend=1e-5, seed=1):
-    """
-    Simulated annealing with adaptive temperature decay and hybrid moves:
-    - Single circle moves most iterations.
-    - Occasionally multi-circle coordinated moves to escape local minima.
-    - Temperature decays smoothly but adaptively slows if improvements are frequent.
-    """
-    rnd = np.random.RandomState(seed)
+def compute_max_radii(centers):
+    # Iterative radii relaxation for all circles simultaneously 
     n = centers.shape[0]
-    best_centers = centers.copy()
-    best_radii = radii.copy()
-    best_sum = radii.sum()
-
-    curr_centers = centers.copy()
-    curr_radii = radii.copy()
-    curr_sum = best_sum
-    T = T0
-    decay_base = (Tend / T0) ** (1.0 / iters)
-
-    multi_prob = 0.07
-    multi_count = 3
-    step_scale = 0.018
-
-    stagnation = 0
-    stagnation_limit = 200
-
-    for it in range(iters):
-        # Adaptive decay: slow down if recent stagnation low
-        if stagnation < stagnation_limit:
-            T = max(T * decay_base, Tend)
-        else:
-            # accelerate cooling after stagnation limit
-            T = max(T * (decay_base ** 3), Tend)
-
-        if rnd.rand() < multi_prob:
-            idxs = rnd.choice(n, multi_count, replace=False)
-            old_ps = curr_centers[idxs].copy()
-            old_rs = curr_radii[idxs].copy()
-            steps = rnd.randn(multi_count, 2) * step_scale
-            new_ps = old_ps + steps
-            new_ps = np.clip(new_ps, 0.0, 1.0)
-            curr_centers[idxs] = new_ps
-            new_rs = np.array([compute_radius_at(i, curr_centers, curr_radii) for i in idxs])
-            if (new_rs > 1e-8).all():
-                new_sum = curr_sum - old_rs.sum() + new_rs.sum()
-                delta = new_sum - curr_sum
-                if delta >= 0 or rnd.rand() < math.exp(delta / T):
-                    curr_radii[idxs] = new_rs
-                    curr_sum = new_sum
-                    if curr_sum > best_sum:
-                        best_sum = curr_sum
-                        best_centers[:] = curr_centers
-                        best_radii[:] = curr_radii
-                        stagnation = 0
-                    else:
-                        stagnation += 1
+    radii = np.minimum.reduce([
+        centers[:,0], centers[:,1],
+        1-centers[:,0], 1-centers[:,1]
+    ])
+    for _ in range(25):
+        changed = False
+        for i in range(n):
+            for j in range(i+1, n):
+                dv = centers[j] - centers[i]
+                d = np.linalg.norm(dv)
+                if d < 1e-8:
+                    if radii[i] > 0 or radii[j] > 0:
+                        radii[i] = 0.0
+                        radii[j] = 0.0
+                        changed = True
                 else:
-                    curr_centers[idxs] = old_ps
-                    stagnation += 1
-            else:
-                curr_centers[idxs] = old_ps
-                stagnation += 1
-        else:
-            i = rnd.randint(n)
-            old_p = curr_centers[i].copy()
-            old_r = curr_radii[i]
-            step = rnd.randn(2) * step_scale
-            new_p = old_p + step
-            new_p = np.clip(new_p, 0.0, 1.0)
-            curr_centers[i] = new_p
-            new_r = compute_radius_at(i, curr_centers, curr_radii)
-            if new_r <= 1e-8:
-                curr_centers[i] = old_p
-                stagnation += 1
-            else:
-                new_sum = curr_sum - old_r + new_r
-                delta = new_sum - curr_sum
-                if delta >= 0 or rnd.rand() < math.exp(delta / T):
-                    curr_radii[i] = new_r
-                    curr_sum = new_sum
-                    if curr_sum > best_sum:
-                        best_sum = curr_sum
-                        best_centers[:] = curr_centers
-                        best_radii[:] = curr_radii
-                        stagnation = 0
-                    else:
-                        stagnation += 1
-                else:
-                    curr_centers[i] = old_p
-                    stagnation += 1
-
-    return best_centers, best_radii
-
-def local_greedy_repack(centers, radii, n_sweeps=3, local_samples=25):
-    """
-    After annealing, perform a local greedy repacking sweep:
-    For each circle, sample candidates around current position and pick best feasible.
-    """
-    c = centers.copy()
-    n = c.shape[0]
-    for sweep in range(n_sweeps):
-        for i in range(n):
-            candidates = []
-            fixed = np.delete(c, i, axis=0)
-            fixed_r = np.delete(radii, i)
-            # Include current position as candidate
-            samples = [c[i]]
-            # Local random perturbations around current position
-            for _ in range(local_samples):
-                offset = 0.05 * (np.random.rand(2) - 0.5)
-                candidate = c[i] + offset
-                candidate = np.clip(candidate, 0.0, 1.0)
-                samples.append(candidate)
-            best_r, best_pos = -1, None
-            for s in samples:
-                r_max = min(s[0], s[1], 1-s[0], 1-s[1])
-                dists = np.linalg.norm(fixed - s, axis=1) - fixed_r
-                min_dist = dists.min() if dists.size > 0 else 1.0
-                r_cand = min(r_max, min_dist)
-                if r_cand > best_r:
-                    best_r = r_cand
-                    best_pos = s
-            if best_r > 0:
-                c[i] = best_pos
-                radii[i] = best_r
-    # Recompute final radii for consistency
-    for i in range(n):
-        radii[i] = compute_radius_at(i, c, radii)
-    return c, radii
-
-def construct_packing():
-    """
-    Construct 26-circle packing with multi-scale greedy initialization,
-    adaptive simulated annealing refinement, and final local greedy repacking.
-    """
-    n = 26
-    centers, radii = multi_scale_greedy_initial(n, base_samples=6000, local_samples=30, seed=42)
-    centers, radii = adaptive_simulated_annealing(centers, radii,
-                                                  iters=18000,
-                                                  T0=0.07,
-                                                  Tend=1e-5,
-                                                  seed=999)
-    centers, radii = local_greedy_repack(centers, radii, n_sweeps=3, local_samples=25)
-    return centers, radii
+                    ri, rj = radii[i], radii[j]
+                    if ri + rj > d:
+                        scale = d / (ri + rj)
+                        radii[i] *= scale
+                        radii[j] *= scale
+                        changed = True
+        if not changed:
+            break
+    return radii
 
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii