# EVOLVE-BLOCK-START
"""Adaptive annealing + multi-layout init + greedy repack for n=26 circle packing"""

import numpy as np

def construct_packing():
    """
    Pack 26 circles in a unit square using:
    - Multiple initial layouts (hexagonal, radial)
    - Adaptive simulated annealing with multi-move perturbations
    - Final local greedy repack sweep
    - Physics-inspired force relaxation
    Returns:
        centers: np.array (26,2)
        radii:   np.array (26,)
    """
    n = 26
    margin = 0.02
    rng = np.random.default_rng(42)

    # --- Phase 1: Diverse Initial Layouts ---
    init_layouts = [
        [6, 5, 6, 5, 4],
        [5, 6, 5, 6, 4],
        [6, 6, 5, 5, 4],
        [5, 5, 6, 6, 4],
        [6, 5, 5, 6, 4],
        [5, 5, 5, 6, 5],
        [4, 6, 6, 5, 5],
        [4, 6, 5, 6, 5],
    ]
    def hex_layout(row_counts):
        max_cols = max(row_counts)
        dx = (1 - 2*margin) / max_cols
        h  = dx * np.sqrt(3) / 2
        centers = np.zeros((n, 2))
        idx = 0
        for rid, cnt in enumerate(row_counts):
            x_start = margin + (max_cols - cnt) * dx / 2
            y = margin + rid * h
            for c in range(cnt):
                centers[idx, 0] = x_start + c * dx
                centers[idx, 1] = y
                idx += 1
        # If not enough, pad with random
        if idx < n:
            pad = rng.uniform(margin, 1-margin, size=(n-idx,2))
            centers[idx:] = pad
        return centers

    def radial_layout():
        c = np.zeros((n,2))
        c[0] = [0.5,0.5]
        for i in range(8):
            θ = 2*np.pi*i/8 + np.pi/16
            c[i+1] = [0.5+0.28*np.cos(θ), 0.5+0.28*np.sin(θ)]
        for i in range(13):
            θ = 2*np.pi*i/13 + np.pi/13
            c[i+9] = [0.5+0.65*np.cos(θ), 0.5+0.65*np.sin(θ)]
        corners = [(margin,margin),(1-margin,margin),(margin,1-margin),(1-margin,1-margin)]
        for k,p in enumerate(corners, start=22):
            c[k] = p
        return c

    layouts = [hex_layout(rows) for rows in init_layouts] + [radial_layout()]
    best_sum = -1
    best_centers = None
    best_radii = None

    for centers in layouts:
        centers = np.clip(centers, margin, 1-margin)
        radii = compute_max_radii(centers)
        s = radii.sum()
        if s > best_sum:
            best_sum = s
            best_centers = centers.copy()
            best_radii = radii.copy()

    # --- Phase 2: Adaptive Simulated Annealing with Multi-Move ---
    anneal_iters = 6000
    T0 = 0.012
    T_min = 1e-5
    alpha = 0.997
    multi_move_prob = 0.18
    stall_limit = 50
    best_sum = np.sum(best_radii)
    curr_centers = best_centers.copy()
    curr_radii = best_radii.copy()
    curr_sum = best_sum
    T = T0
    stall_count = 0

    for it in range(anneal_iters):
        # Multi-move: perturb 2-3 circles with probability
        if rng.uniform() < multi_move_prob:
            count = rng.integers(2, 4)
            idxs = rng.choice(n, size=count, replace=False)
        else:
            idxs = [rng.integers(n)]
        trial = curr_centers.copy()
        scale = 0.031 * (T/T0)**0.4
        trial[idxs] += rng.normal(0, scale, size=(len(idxs),2))
        trial = np.clip(trial, margin, 1-margin)
        trial_radii = compute_max_radii(trial)
        if np.all(trial_radii > 1e-7):
            trial_sum = np.sum(trial_radii)
            dE = trial_sum - curr_sum
            accept = False
            if dE > 1e-9:
                accept = True
            elif rng.uniform() < np.exp(dE/T):
                accept = True
            if accept:
                curr_centers = trial
                curr_radii = trial_radii
                curr_sum = trial_sum
                stall_count = 0
                if curr_sum > best_sum + 1e-9:
                    best_sum = curr_sum
                    best_centers = curr_centers.copy()
                    best_radii = curr_radii.copy()
            else:
                stall_count += 1
        else:
            stall_count += 1
        # Adaptive cooling
        if stall_count >= stall_limit and T > T_min:
            T *= alpha ** 2.5
            stall_count = 0
        else:
            T *= alpha
        if T < T_min:
            T = T_min

    # --- Phase 3: Local Greedy Repack Sweep ---
    repack_passes = 3
    centers = best_centers.copy()
    radii   = best_radii.copy()
    for repack_pass in range(repack_passes):
        for i in range(n):
            others = np.delete(centers, i, axis=0)
            probes = centers[i] + rng.uniform(-0.11, 0.11, (32,2))
            probes = np.clip(probes, margin, 1-margin)
            probes = np.vstack([probes, centers[i]])
            max_rad = 0.
            best_probe = centers[i]
            for p in probes:
                border_r = min(p[0]-margin, p[1]-margin, 1-margin-p[0], 1-margin-p[1])
                sep = np.linalg.norm(others - p, axis=1)
                safe_sep = sep.min() if len(sep)>0 else border_r
                cand_r = min(border_r, safe_sep)
                if cand_r > max_rad:
                    max_rad = cand_r
                    best_probe = p
            centers[i] = best_probe
        radii = compute_max_radii(centers)

    # --- Phase 4: Physics-inspired Force Relaxation ---
    force_steps = 40
    centers = physics_relaxation(centers, radii, steps=force_steps, margin=margin)
    radii = compute_max_radii(centers)
    return centers, radii

def physics_relaxation(centers, radii, steps=40, margin=0.02):
    """
    Physics-inspired repulsive force refinement of circle centers.
    Args:
        centers: (n,2) array of current centers
        radii:   (n,) array of current radii
        steps:   number of force relaxation steps
        margin:  margin from square boundary
    Returns:
        refined_centers: (n,2) array
    """
    n = centers.shape[0]
    centers = centers.copy()
    for step in range(steps):
        forces = np.zeros_like(centers)
        # Pairwise repulsive forces for overlap or near-overlap
        for i in range(n):
            for j in range(i+1, n):
                d_vec = centers[j] - centers[i]
                dist = np.linalg.norm(d_vec)
                min_dist = radii[i] + radii[j] + 1e-6
                if dist < min_dist:
                    if dist > 1e-8:
                        direction = d_vec / dist
                    else:
                        direction = np.random.uniform(-1,1,2)
                        direction /= np.linalg.norm(direction)
                    overlap = min_dist - dist
                    f = 0.18 * overlap * direction
                    forces[i] -= f
                    forces[j] += f
        # Boundary repulsion
        for i in range(n):
            x, y = centers[i]
            r = radii[i]
            # Left
            if x - r < margin:
                forces[i,0] += 0.18 * (margin - (x - r))
            # Right
            if x + r > 1 - margin:
                forces[i,0] -= 0.18 * ((x + r) - (1 - margin))
            # Bottom
            if y - r < margin:
                forces[i,1] += 0.18 * (margin - (y - r))
            # Top
            if y + r > 1 - margin:
                forces[i,1] -= 0.18 * ((y + r) - (1 - margin))
        # Adaptive step size: smaller as steps increase
        step_size = 0.13 * (1 - step/steps) + 0.04
        centers += step_size * forces
        centers = np.clip(centers, margin, 1 - margin)
    return centers

def compute_max_radii(centers):
    """
    Given circle centers, compute the maximal non-overlapping radii
    within the unit square by iteratively enforcing border and pairwise constraints.
    """
    n = centers.shape[0]
    radii = np.minimum.reduce([
        centers[:,0],            # distance to left
        centers[:,1],            # distance to bottom
        1 - centers[:,0],        # right
        1 - centers[:,1]         # top
    ])
    for _ in range(14):
        changed = False
        for i in range(n):
            for j in range(i+1, n):
                d = np.hypot(*(centers[i] - centers[j]))
                if d <= 0:
                    if radii[i] != 0.0 or radii[j] != 0.0:
                        radii[i] = radii[j] = 0.0
                        changed = True
                else:
                    ri, rj = radii[i], radii[j]
                    if ri + rj > d:
                        scale = d / (ri + rj)
                        new_ri = ri * scale
                        new_rj = rj * scale
                        if new_ri < ri or new_rj < rj:
                            radii[i] = new_ri
                            radii[j] = new_rj
                            changed = True
        if not changed:
            break
    return radii

# EVOLVE-BLOCK-END

# This part remains fixed (not evolved)
def run_packing():
    """Run the circle packing constructor for n=26"""
    centers, radii = construct_packing()
    # Calculate the sum of radii
    sum_radii = np.sum(radii)
    return centers, radii, sum_radii