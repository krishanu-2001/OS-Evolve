<NAME>
adaptive_cooling_schedule
</NAME>

<DESCRIPTION>
Implement an adaptive cooling schedule during the simulated annealing phase to dynamically adjust the temperature based on the recent rate of improvement. This approach allows the algorithm to slow down cooling when improvements are frequent, encouraging deeper exploration, and speed up when progress stalls, preventing unnecessary computation. It can help escape shallow local minima and potentially improve the maximum sum of radii.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
T0 = 0.001
centers_sa = centers.copy()
radii_sa = radii.copy()
sum_sa = radii_sa.sum()
for k in range(2000):
    i = np.random.randint(n)
    old_pos = centers_sa[i].copy()
    # decaying perturbation
    delta = np.random.randn(2) * (0.005 * (1 - k / 2000))
    centers_sa[i] = np.clip(centers_sa[i] + delta, 0.01, 0.99)
    radii_tmp = compute_max_radii(centers_sa)
    sum_new = radii_tmp.sum()
    T = T0 * (1 - k / 2000)
    if sum_new > sum_sa or np.random.rand() < np.exp((sum_new - sum_sa) / max(T, 1e-12)):
        sum_sa = sum_new
        radii_sa = radii_tmp
    else:
        centers_sa[i] = old_pos
=======
T0 = 0.001
centers_sa = centers.copy()
radii_sa = radii.copy()
sum_sa = radii_sa.sum()

# Initialize adaptive parameters
improvement_counter = 0
no_improve_counter = 0
max_no_improve = 100
improvement_threshold = 1e-4
initial_temp = T0
temp = initial_temp

for k in range(2000):
    i = np.random.randint(n)
    old_pos = centers_sa[i].copy()
    # decaying perturbation
    delta = np.random.randn(2) * (0.005 * (1 - k / 2000))
    centers_sa[i] = np.clip(centers_sa[i] + delta, 0.01, 0.99)
    radii_tmp = compute_max_radii(centers_sa)
    sum_new = radii_tmp.sum()

    # Adaptive temperature adjustment based on recent improvements
    if sum_new > sum_sa + improvement_threshold:
        improvement_counter += 1
        no_improve_counter = 0
    else:
        no_improve_counter += 1

    # Adjust temperature
    if no_improve_counter >= max_no_improve:
        # Increase temperature to escape local minima
        temp = min(temp * 1.1, 0.01)
        no_improve_counter = 0
    elif improvement_counter >= 10:
        # Decrease temperature to refine
        temp = max(temp * 0.9, 1e-6)
        improvement_counter = 0

    T = temp
    # Acceptance criterion with adaptive T
    delta_score = sum_new - sum_sa
    if delta_score > 0 or np.random.rand() < np.exp(delta_score / max(T, 1e-12)):
        sum_sa = sum_new
        radii_sa = radii_tmp
    else:
        centers_sa[i] = old_pos
>>>>>>> REPLACE