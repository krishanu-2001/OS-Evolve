<CLUSTER_MOVE_ENHANCEMENT>
Enhance adaptive simulated annealing by increasing frequency and scale of cluster moves and adding adaptive local step sizes depending on circle confinement. Also, enhance local greedy repacking by adding localized micro-adjustment phase after main repacking to relieve small overlaps and further optimize radii sum.
</CLUSTER_MOVE_ENHANCEMENT>

<DIFF>
<<<<<<< SEARCH
def adaptive_simulated_annealing(centers, radii, margin, rng):
    """
    Perform adaptive simulated annealing with cluster moves and adaptive temperature schedule.
    """
    n = centers.shape[0]
    best_centers = centers.copy()
    best_radii = radii.copy()
    best_score = np.sum(radii)

    current_centers = centers.copy()
    current_radii = radii.copy()
    current_score = best_score

    # KD-tree for neighbor queries
    tree = cKDTree(current_centers)

    T_init = 1e-2
    T_min = 1e-5
    T = T_init

    max_iters = 12000
    stagnation = 0
    max_stagn = 400
    alpha_fast = 0.995
    alpha_slow = 0.9995

    for it in range(max_iters):
        # Adaptive temperature decay
        if stagnation < max_stagn:
            T *= alpha_slow
        else:
            T *= alpha_fast
        if T < T_min:
            T = T_min

        candidate_centers = current_centers.copy()

        # Periodic multi-circle cluster move every 100 iterations
        if it % 100 == 0:
            idx = rng.integers(n)
            neighbors = tree.query_ball_point(current_centers[idx], r=0.15)
            if len(neighbors) > 3:
                neighbors = rng.choice(neighbors, size=3, replace=False)
            step_size = 0.01 * (T / T_init)**0.5
            delta = rng.uniform(-step_size, step_size, size=2)
            for i in neighbors:
                candidate_centers[i] += delta
                candidate_centers[i] = np.clip(candidate_centers[i], margin, 1 - margin)
        else:
            # Decide cluster or single move
            if rng.uniform() < 0.25:
                # Cluster move: select a random circle and move it and its neighbors
                idx = rng.integers(n)
                neighbors = tree.query_ball_point(current_centers[idx], r=0.15)
                # limit cluster size to max 4
                if len(neighbors) > 4:
                    neighbors = rng.choice(neighbors, size=4, replace=False)
                step_size = 0.02 * (T / T_init)**0.5
                delta = rng.uniform(-step_size, step_size, size=2)
                for i in neighbors:
                    candidate_centers[i] += delta
                    candidate_centers[i] = np.clip(candidate_centers[i], margin, 1 - margin)
            else:
                # Single circle move
                idx = rng.integers(n)
                step_size = 0.03 * (T / T_init)**0.5
                delta = rng.uniform(-step_size, step_size, size=2)
                candidate_centers[idx] += delta
                candidate_centers[idx] = np.clip(candidate_centers[idx], margin, 1 - margin)

        candidate_radii = compute_max_radii(candidate_centers)
        candidate_score = np.sum(candidate_radii)
        dE = candidate_score - current_score

        if dE > 0 or rng.uniform() < np.exp(dE / T):
            current_centers = candidate_centers
            current_radii = candidate_radii
            current_score = candidate_score
            tree = cKDTree(current_centers)
            if current_score > best_score:
                best_centers = current_centers.copy()
                best_radii = current_radii.copy()
                best_score = current_score
                stagnation = 0
            else:
                stagnation += 1
        else:
            stagnation += 1

        # Restart temperature if stagnation too long to escape local minima
        if stagnation > 1000:
            T = T_init
            stagnation = 0

    return best_centers, best_radii


def local_greedy_repacking(centers, radii, margin):
    """
    For each circle, locally optimize its position by small moves to increase sum of radii.
    """
    n = centers.shape[0]
    centers = centers.copy()
    radii = radii.copy()
    rng = np.random.default_rng(98765)

    max_local_iters = 2000
    step = 0.01

    for _ in range(max_local_iters):
        improved = False
        for i in range(n):
            base_center = centers[i].copy()
            base_radii = compute_max_radii(centers)
            base_sum = np.sum(base_radii)

            # Try small random moves in 8 directions
            directions = np.array([
                [step,0], [-step,0], [0,step], [0,-step],
                [step,step], [step,-step], [-step,step], [-step,-step]
            ])

            best_local_center = base_center.copy()
            best_local_sum = base_sum

            for d in directions:
                new_center = base_center + d
                new_center = np.clip(new_center, margin, 1 - margin)
                centers[i] = new_center
                new_radii = compute_max_radii(centers)
                new_sum = np.sum(new_radii)
                if new_sum > best_local_sum:
                    best_local_sum = new_sum
                    best_local_center = new_center.copy()

            centers[i] = best_local_center
            if best_local_sum > base_sum + 1e-8:
                improved = True

        if not improved:
            break

    radii = compute_max_radii(centers)
    return centers, radii
=======
def adaptive_simulated_annealing(centers, radii, margin, rng):
    """
    Perform adaptive simulated annealing with cluster moves and adaptive temperature schedule.
    """
    n = centers.shape[0]
    best_centers = centers.copy()
    best_radii = radii.copy()
    best_score = np.sum(radii)

    current_centers = centers.copy()
    current_radii = radii.copy()
    current_score = best_score

    # KD-tree for neighbor queries
    tree = cKDTree(current_centers)

    T_init = 1e-2
    T_min = 1e-5
    T = T_init

    max_iters = 12000
    stagnation = 0
    max_stagn = 300
    alpha_fast = 0.994
    alpha_slow = 0.9998

    for it in range(max_iters):
        # Adaptive temperature decay
        if stagnation < max_stagn:
            T *= alpha_slow
        else:
            T *= alpha_fast
        if T < T_min:
            T = T_min

        candidate_centers = current_centers.copy()

        # Periodic multi-circle cluster move every 50 iterations with bigger step
        if it % 50 == 0:
            idx = rng.integers(n)
            neighbors = tree.query_ball_point(current_centers[idx], r=0.18)
            if len(neighbors) > 5:
                neighbors = rng.choice(neighbors, size=5, replace=False)
            # Increase step size at cluster moves for better exploration
            step_size = 0.03 * (T / T_init)**0.5
            delta = rng.uniform(-step_size, step_size, size=2)
            for i in neighbors:
                candidate_centers[i] += delta
                candidate_centers[i] = np.clip(candidate_centers[i], margin, 1 - margin)
        else:
            # Decide cluster or single move with increased cluster probability
            if rng.uniform() < 0.40:
                idx = rng.integers(n)
                neighbors = tree.query_ball_point(current_centers[idx], r=0.15)
                if len(neighbors) > 4:
                    neighbors = rng.choice(neighbors, size=4, replace=False)
                step_size = 0.025 * (T / T_init)**0.5
                delta = rng.uniform(-step_size, step_size, size=2)
                for i in neighbors:
                    candidate_centers[i] += delta
                    candidate_centers[i] = np.clip(candidate_centers[i], margin, 1 - margin)
            else:
                idx = rng.integers(n)
                # Adaptive step size depending on circle confinement: smaller step if circle radius is small
                confinement = radii[idx]
                base_step = 0.04 * (T / T_init)**0.5
                step_size = base_step * np.clip(confinement * 10.0, 0.2, 1.0)
                delta = rng.uniform(-step_size, step_size, size=2)
                candidate_centers[idx] += delta
                candidate_centers[idx] = np.clip(candidate_centers[idx], margin, 1 - margin)

        candidate_radii = compute_max_radii(candidate_centers)
        candidate_score = np.sum(candidate_radii)
        dE = candidate_score - current_score

        if dE > 0 or rng.uniform() < np.exp(dE / T):
            current_centers = candidate_centers
            current_radii = candidate_radii
            current_score = candidate_score
            tree = cKDTree(current_centers)
            if current_score > best_score:
                best_centers = current_centers.copy()
                best_radii = current_radii.copy()
                best_score = current_score
                stagnation = 0
            else:
                stagnation += 1
        else:
            stagnation += 1

        # Restart temperature if stagnation too long to escape local minima
        if stagnation > 900:
            T = T_init
            stagnation = 0

    return best_centers, best_radii


def local_greedy_repacking(centers, radii, margin):
    """
    For each circle, locally optimize its position by small moves to increase sum of radii,
    then perform a constraint-aware force-based micro-adjustment phase to fine-tune.
    """
    n = centers.shape[0]
    centers = centers.copy()
    radii = radii.copy()
    rng = np.random.default_rng(98765)

    max_local_iters = 3000
    step = 0.008

    for _ in range(max_local_iters):
        improved = False
        for i in range(n):
            base_center = centers[i].copy()
            base_radii = compute_max_radii(centers)
            base_sum = np.sum(base_radii)

            directions = np.array([
                [step,0], [-step,0], [0,step], [0,-step],
                [step,step], [step,-step], [-step,step], [-step,-step]
            ])

            best_local_center = base_center.copy()
            best_local_sum = base_sum

            for d in directions:
                new_center = base_center + d
                new_center = np.clip(new_center, margin, 1 - margin)
                centers[i] = new_center
                new_radii = compute_max_radii(centers)
                new_sum = np.sum(new_radii)
                if new_sum > best_local_sum:
                    best_local_sum = new_sum
                    best_local_center = new_center.copy()

            centers[i] = best_local_center
            if best_local_sum > base_sum + 1e-8:
                improved = True

        if not improved:
            break

    radii = compute_max_radii(centers)

    # Micro-adjustment phase for subtle overlap relief and final optimization
    fmax_iter = 2000
    force_step = step / 4
    for _ in range(fmax_iter):
        force_improved = False
        radii = compute_max_radii(centers)
        for i in range(n):
            force = np.zeros(2)
            ci = centers[i]
            ri = radii[i]

            # Repulsive forces from borders to keep inside with margin
            for dim in range(2):
                dist_to_low = ci[dim] - margin
                dist_to_high = 1 - margin - ci[dim]
                if dist_to_low < ri:
                    force[dim] += (ri - dist_to_low)
                if dist_to_high < ri:
                    force[dim] -= (ri - dist_to_high)

            # Repulsive forces from neighbors
            for j in range(n):
                if j == i:
                    continue
                cj = centers[j]
                rj = radii[j]
                vec = ci - cj
                d = np.linalg.norm(vec)+1e-12
                overlap = ri + rj - d
                if overlap > 0:
                    force += (vec / d) * overlap * 0.5

            if np.linalg.norm(force) > 1e-8:
                new_ci = ci + force * force_step
                new_ci = np.clip(new_ci, margin, 1 - margin)
                old_radii = radii[i]
                centers[i] = new_ci
                new_radii = compute_max_radii(centers)
                new_sum = np.sum(new_radii)
                old_sum = np.sum(radii)

                if new_sum > old_sum:
                    radii = new_radii
                    force_improved = True
                else:
                    centers[i] = ci

        if not force_improved:
            break

    radii = compute_max_radii(centers)
    return centers, radii
>>>>>>> REPLACE