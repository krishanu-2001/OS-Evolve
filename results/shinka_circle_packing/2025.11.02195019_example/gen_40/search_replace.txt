<NAME>add_post_optimization_simulated_annealing</NAME>
<DESCRIPTION>
Introduce a brief simulated annealing phase at the end of construct_packing to perform adaptive multi‐center random perturbations with decaying step size, accepting only improvements in total radius sum. This helps escape shallow local minima and refines the initial ring‐based layout.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    # Compute maximum valid radii for this configuration
    radii = compute_max_radii(centers)
    return centers, radii
=======
    # Compute maximum valid radii for this configuration
    radii = compute_max_radii(centers)

    # Post-optimization: brief simulated annealing to tweak centers
    best_centers = centers.copy()
    best_radii = radii.copy()
    best_sum = np.sum(radii)
    np.random.seed(1)
    for it in range(500):
        k = np.random.randint(1, 4)  # move 1-3 circles
        idxs = np.random.choice(n, k, replace=False)
        scale = 0.05 * (0.995 ** it)
        trial = centers.copy()
        trial[idxs] += np.random.randn(k, 2) * scale
        trial = np.clip(trial, 0.01, 0.99)
        trial_radii = compute_max_radii(trial)
        s = np.sum(trial_radii)
        if s > best_sum + 1e-8:
            centers = trial
            best_sum = s
            best_centers = trial.copy()
            best_radii = trial_radii.copy()
    centers, radii = best_centers, best_radii
    return centers, radii
>>>>>>> REPLACE
</DIFF>

<NAME>iterative_pairwise_radius_refinement</NAME>
<DESCRIPTION>
Enhance compute_max_radii by iteratively enforcing pairwise non‐overlap constraints until convergence (or up to 20 passes), rather than a single sweep. This tightens radii more accurately and ensures a denser valid packing.
</DESCRIPTION>
<DIFF>
<<<<<<< SEARCH
    # Then, limit by distance to other circles
    # Each pair of circles with centers at distance d can have
    # sum of radii at most d to avoid overlap
    for i in range(n):
        for j in range(i + 1, n):
            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))

            # If current radii would cause overlap
            if radii[i] + radii[j] > dist:
                # Scale both radii proportionally
                scale = dist / (radii[i] + radii[j])
                radii[i] *= scale
                radii[j] *= scale

    return radii
=======
    # Then, limit by distance to other circles: iterate until convergence
    for _ in range(20):
        changed = False
        for i in range(n):
            for j in range(i + 1, n):
                d = np.linalg.norm(centers[i] - centers[j])
                if radii[i] + radii[j] > d:
                    scale = d / (radii[i] + radii[j] + 1e-12)
                    old_i, old_j = radii[i], radii[j]
                    radii[i] *= scale
                    radii[j] *= scale
                    if abs(radii[i] - old_i) > 1e-8 or abs(radii[j] - old_j) > 1e-8:
                        changed = True
        if not changed:
            break

    return radii
>>>>>>> REPLACE
</DIFF>