<NAME>
adaptive_sampling_and_local_refinement
</NAME>

<DESCRIPTION>
Improves the greedy initialization by adaptively increasing the number of samples for later circles to better fill gaps, and adds a local refinement step after greedy initialization to fine-tune circle positions and radii before simulated annealing. This should help find better initial configurations and improve final packing quality.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def greedy_initial(n, samples=8000, seed=0):
    """
    Sequentially place n circles.
    At each step, sample 'samples' random points and pick the one
    with the largest feasible radius given existing circles.
    """
    rnd = np.random.RandomState(seed)
    centers = []
    radii = []
    for k in range(n):
        pts = rnd.rand(samples,2)
        best_r = -1.0
        best_p = None
        if k == 0:
            # for first circle just pick the best by walls
            xs = pts[:,0]; ys = pts[:,1]
            rs = np.minimum.reduce([xs, ys, 1-xs, 1-ys])
            idx = np.argmax(rs)
            best_r = rs[idx]; best_p = pts[idx]
        else:
            arr_centers = np.array(centers)
            arr_radii = np.array(radii)
            for p in pts:
                # radius limited by walls
                r = min(p[0], p[1], 1-p[0], 1-p[1])
                # limit by existing circles
                d = np.linalg.norm(arr_centers - p, axis=1) - arr_radii
                r = min(r, d.min())
                if r > best_r:
                    best_r = r; best_p = p
        centers.append(best_p)
        radii.append(max(best_r, 1e-6))
    return np.array(centers), np.array(radii)
=======
def greedy_initial(n, samples=8000, seed=0):
    """
    Sequentially place n circles.
    At each step, sample 'samples' random points and pick the one
    with the largest feasible radius given existing circles.
    Adaptive sampling: increase samples for later circles to fill gaps better.
    """
    rnd = np.random.RandomState(seed)
    centers = []
    radii = []
    base_samples = samples // 4
    for k in range(n):
        # Increase samples for later circles to better fill gaps
        current_samples = base_samples + int(base_samples * (k / max(1, n-1)) * 3)
        pts = rnd.rand(current_samples, 2)
        best_r = -1.0
        best_p = None
        if k == 0:
            # for first circle just pick the best by walls
            xs = pts[:,0]; ys = pts[:,1]
            rs = np.minimum.reduce([xs, ys, 1-xs, 1-ys])
            idx = np.argmax(rs)
            best_r = rs[idx]; best_p = pts[idx]
        else:
            arr_centers = np.array(centers)
            arr_radii = np.array(radii)
            for p in pts:
                # radius limited by walls
                r = min(p[0], p[1], 1-p[0], 1-p[1])
                # limit by existing circles
                d = np.linalg.norm(arr_centers - p, axis=1) - arr_radii
                r = min(r, d.min())
                if r > best_r:
                    best_r = r; best_p = p
        centers.append(best_p)
        radii.append(max(best_r, 1e-6))

    # Local refinement step after greedy placement to improve radii
    centers, radii = local_refinement(centers, radii, rnd)
    return np.array(centers), np.array(radii)

def local_refinement(centers, radii, rnd, iterations=5, local_scale=0.05):
    """
    For each circle, try small local perturbations to increase radius.
    """
    centers = np.array(centers)
    radii = np.array(radii)
    n = len(centers)
    for _ in range(iterations):
        for i in range(n):
            best_r = radii[i]
            best_p = centers[i].copy()
            for _ in range(30):
                candidate = centers[i] + (rnd.rand(2)*2 - 1) * local_scale
                candidate = np.clip(candidate, 0.0, 1.0)
                # Compute max radius at candidate position
                r = min(candidate[0], candidate[1], 1-candidate[0], 1-candidate[1])
                if n > 1:
                    others = np.delete(centers, i, axis=0)
                    other_rs = np.delete(radii, i)
                    d = np.linalg.norm(others - candidate, axis=1) - other_rs
                    r = min(r, d.min())
                if r > best_r:
                    best_r = r
                    best_p = candidate
            centers[i] = best_p
            radii[i] = best_r
    return centers, radii
>>>>>>> REPLACE