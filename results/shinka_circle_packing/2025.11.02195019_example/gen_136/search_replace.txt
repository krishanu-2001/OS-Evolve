<adaptive_multi_scale_sampling>
Adaptive multi-scale local sampling in greedy initialization to better fill gaps and edges.

This edit improves the multi-scale greedy initialization by dynamically adjusting the number of local samples per scale based on the current iteration index. Early iterations focus on larger scales with fewer samples, while later iterations increase sampling density at smaller scales to fill finer gaps. This adaptive approach better balances exploration and exploitation, potentially leading to denser initial packings and improved final results.
</adaptive_multi_scale_sampling>

<DIFF>
<<<<<<< SEARCH
def multi_scale_greedy_initial(n, base_samples=6000, local_samples=30, seed=0):
    """
    Multi-scale greedy initialization:
    - At each placement step, sample many random points globally.
    - Additionally, sample multiple local points around existing circles'
      edges at different scales to fill gaps.
    - Choose the candidate point with the largest feasible radius.
    """
    rnd = np.random.RandomState(seed)
    centers = []
    radii = []
    for k in range(n):
        # Global random samples
        pts = rnd.rand(base_samples, 2)
        # Local multi-scale samples around placed circles
        if k > 0:
            arr_centers = np.array(centers)
            arr_radii = np.array(radii)
            local_pts_list = []
            scales = [0.015, 0.035, 0.07]  # multiple scales for gap filling
            for c, r in zip(arr_centers, arr_radii):
                for scale in scales:
                    angles = rnd.rand(local_samples)*2*np.pi
                    radii_local = r + scale + rnd.rand(local_samples)*scale*0.5
                    xs = c[0] + radii_local * np.cos(angles)
                    ys = c[1] + radii_local * np.sin(angles)
                    pts_local = np.stack([xs, ys], axis=1)
                    # Keep only points inside unit square
                    pts_local = pts_local[(pts_local[:,0]>=0) & (pts_local[:,0]<=1) & (pts_local[:,1]>=0) & (pts_local[:,1]<=1)]
                    local_pts_list.append(pts_local)
            if local_pts_list:
                pts = np.vstack([pts] + local_pts_list)
        best_r = -1.0
        best_p = None
        if k == 0:
            # For first circle pick max radius limited by borders
            xs = pts[:,0]; ys = pts[:,1]
            rs = np.minimum.reduce([xs, ys, 1-xs, 1-ys])
            idx = np.argmax(rs)
            best_r = rs[idx]; best_p = pts[idx]
        else:
            arr_centers = np.array(centers)
            arr_radii = np.array(radii)
            for p in pts:
                # radius limited by borders
                r = min(p[0], p[1], 1-p[0], 1-p[1])
                # limit by existing circles
                d = np.linalg.norm(arr_centers - p, axis=1) - arr_radii
                r = min(r, d.min())
                if r > best_r:
                    best_r = r; best_p = p
        centers.append(best_p)
        radii.append(max(best_r, 1e-8))
    return np.array(centers), np.array(radii)
=======
def multi_scale_greedy_initial(n, base_samples=6000, local_samples=30, seed=0):
    """
    Multi-scale greedy initialization:
    - At each placement step, sample many random points globally.
    - Additionally, sample multiple local points around existing circles'
      edges at different scales to fill gaps.
    - Choose the candidate point with the largest feasible radius.
    """
    rnd = np.random.RandomState(seed)
    centers = []
    radii = []
    for k in range(n):
        # Global random samples
        pts = rnd.rand(base_samples, 2)
        # Local multi-scale samples around placed circles with adaptive sample counts
        if k > 0:
            arr_centers = np.array(centers)
            arr_radii = np.array(radii)
            local_pts_list = []
            scales = [0.07, 0.035, 0.015]  # start from larger scales to smaller
            # Adaptive local sample counts per scale: fewer samples at large scale early, more at small scale later
            scale_weights = [max(1, int(local_samples * (1 - k / n) * 0.5)),
                             max(1, int(local_samples * (k / n) * 0.7)),
                             max(1, int(local_samples * (k / n) * 1.2))]
            for c, r in zip(arr_centers, arr_radii):
                for scale, count in zip(scales, scale_weights):
                    angles = rnd.rand(count)*2*np.pi
                    radii_local = r + scale + rnd.rand(count)*scale*0.5
                    xs = c[0] + radii_local * np.cos(angles)
                    ys = c[1] + radii_local * np.sin(angles)
                    pts_local = np.stack([xs, ys], axis=1)
                    # Keep only points inside unit square
                    pts_local = pts_local[(pts_local[:,0]>=0) & (pts_local[:,0]<=1) & (pts_local[:,1]>=0) & (pts_local[:,1]<=1)]
                    local_pts_list.append(pts_local)
            if local_pts_list:
                pts = np.vstack([pts] + local_pts_list)
        best_r = -1.0
        best_p = None
        if k == 0:
            # For first circle pick max radius limited by borders
            xs = pts[:,0]; ys = pts[:,1]
            rs = np.minimum.reduce([xs, ys, 1-xs, 1-ys])
            idx = np.argmax(rs)
            best_r = rs[idx]; best_p = pts[idx]
        else:
            arr_centers = np.array(centers)
            arr_radii = np.array(radii)
            for p in pts:
                # radius limited by borders
                r = min(p[0], p[1], 1-p[0], 1-p[1])
                # limit by existing circles
                d = np.linalg.norm(arr_centers - p, axis=1) - arr_radii
                r = min(r, d.min())
                if r > best_r:
                    best_r = r; best_p = p
        centers.append(best_p)
        radii.append(max(best_r, 1e-8))
    return np.array(centers), np.array(radii)
>>>>>>> REPLACE