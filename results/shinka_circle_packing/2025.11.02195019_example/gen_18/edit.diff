--- a/original.py
+++ b/original.py
@@ -1,136 +1,191 @@
 # EVOLVE-BLOCK-START
-"""Modular physics-based circle packing for n=26 circles with vectorized operations"""
-
 import numpy as np
 
-def initialize_centers(n, seed=0):
-    """
-    Initialize circle centers on a jittered grid inside [0.1,0.9]^2.
-    """
-    np.random.seed(seed)
-    gx = np.linspace(0.1, 0.9, 6)
-    gy = np.linspace(0.1, 0.9, 5)
-    pts = np.array([(x, y) for x in gx for y in gy])
-    centers = pts[:n].copy()
-    jitter = (np.random.rand(n, 2) - 0.5) * 0.02
-    centers += jitter
-    return np.clip(centers, 0.01, 0.99)
+def layout_candidates():
+    # Possible row splits summing to 26 circles
+    # Focus on splits with <=7 circles per row, 4-6 rows total
+    return [
+        [6,5,6,5,4],
+        [5,5,6,5,5],
+        [5,6,5,6,4],
+        [4,6,6,5,5],
+        [6,6,5,5,4],
+        [5,6,6,4,5]
+    ]
 
-def compute_max_radii(centers, relaxation_iters=5):
-    """
-    Compute max possible radii so circles fit inside [0,1]^2 and don't overlap.
-    Uses iterative relaxation to enforce pairwise constraints.
-    """
+def hex_row_centers(count, y, x_margin=0.05, y_margin=0.05, width=1.0):
+    # Centers arranged with hex spacing along x at given y height
+    # Use hex spacing: horizontal spacing = 2r, vertical spacing adjusted by sqrt(3)
+    # Here generate equally spaced points with optional jitter
+    if count == 1:
+        return np.array([[width/2, y]])
+    spacing = (width - 2*x_margin) / (count - 1) if count > 1 else 0
+    xs = x_margin + np.arange(count) * spacing
+    centers = np.stack([xs, np.full(count, y)], axis=1)
+    # jitter on x slightly (up to 0.007) helps relaxation but small enough
+    jitter = (np.random.rand(count) - 0.5) * 0.014
+    centers[:,0] += jitter
+    return centers
+
+def assign_size_gradient(centers):
+    # Assign target sizes with larger radii near center of square and center rows
+    # Radius priority based on distance from center (0.5,0.5)
+    # Use a Gaussian decay from center, emphasizing middle rows
+    dist_center = np.linalg.norm(centers - 0.5, axis=1)
+    # invert distance, normalize, and apply a softmax-like exponent for size gradient
+    max_dist = np.sqrt(2*0.5**2)
+    norm_dist = dist_center / max_dist
+    # size factor (higher size when norm_dist low)
+    size_factor = np.exp(- (norm_dist*4)**2)
+    # normalize size_factor to max 1, min ~0.1
+    size_factor = 0.1 + 0.9 * (size_factor - size_factor.min())/(size_factor.max() - size_factor.min() + 1e-10)
+    return size_factor
+
+def compute_max_radii(centers, max_iters=10):
     n = centers.shape[0]
-    xs, ys = centers[:, 0], centers[:, 1]
-    radii = np.minimum.reduce([xs, ys, 1 - xs, 1 - ys])
-
-    for _ in range(relaxation_iters):
-        # Vectorized pairwise distance matrix
-        diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]  # shape (n,n,2)
-        dist = np.linalg.norm(diff, axis=2) + np.eye(n)  # add eye to avoid zero distance on diagonal
-        sum_radii = radii[:, np.newaxis] + radii[np.newaxis, :]
-        overlap_mask = (sum_radii > dist) & (dist > 0)
-
-        # For each overlapping pair, compute scale factor
-        scale = np.ones_like(dist)
-        scale[overlap_mask] = dist[overlap_mask] / sum_radii[overlap_mask]
-
-        # For each circle, find minimal scale imposed by any overlap
-        min_scale = scale.min(axis=1)
-        radii *= min_scale
-        # Prevent radii from becoming negative or zero
-        radii = np.maximum(radii, 1e-6)
+    radii = np.minimum.reduce([centers[:,0], centers[:,1], 1 - centers[:,0], 1 - centers[:,1]])
+    # Iterative tightening for pairwise constraints until convergence or max_iters
+    for _ in range(max_iters):
+        changed = False
+        for i in range(n):
+            for j in range(i+1, n):
+                d = np.linalg.norm(centers[i]-centers[j])
+                if d <= 1e-14:
+                    continue # skip identical points just in case
+                if radii[i] + radii[j] > d:
+                    scale = d / (radii[i] + radii[j])
+                    # Apply scale only if it reduces radii (strict monotonic)
+                    if scale < 1.0 - 1e-8:
+                        radii[i] *= scale
+                        radii[j] *= scale
+                        changed = True
+        if not changed:
+            break
+    # Avoid tiny or zero radii
+    radii = np.maximum(radii, 1e-6)
     return radii
 
 def compute_forces(centers, radii):
-    """
-    Compute repulsion forces between overlapping circles and corrective forces from borders.
-    Returns force array of shape (n,2).
-    """
     n = centers.shape[0]
     forces = np.zeros_like(centers)
+    # Pairwise differences and distances
+    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]  # shape (n,n,2)
+    dist = np.linalg.norm(diff, axis=2) + np.eye(n)
+    sum_r = radii[:, None] + radii[None, :]
+    overlap = sum_r - dist
+    overlap_mask = (overlap > 0) & (~np.eye(n, dtype=bool))
 
-    # Vectorized pairwise differences and distances
-    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]  # (n,n,2)
-    dist = np.linalg.norm(diff, axis=2) + np.eye(n)  # (n,n), add eye to avoid zero division
-    sum_radii = radii[:, np.newaxis] + radii[np.newaxis, :]
-
-    overlap = sum_radii - dist
-    overlap_mask = (overlap > 0) & (np.eye(n) == 0)  # exclude diagonal
-
-    # Compute normalized direction vectors for overlaps
+    # Direction: from j to i
     direction = np.zeros_like(diff)
+    # Safely compute direction only where overlap
     direction[overlap_mask] = diff[overlap_mask] / dist[overlap_mask][:, None]
 
-    # Repulsion force magnitude proportional to overlap
-    force_magnitudes = np.zeros((n, n))
-    force_magnitudes[overlap_mask] = overlap[overlap_mask] / dist[overlap_mask]
+    # Repulsion proportional to overlap squared (stronger)
+    strength = np.zeros_like(dist)
+    strength[overlap_mask] = overlap[overlap_mask] ** 2 / dist[overlap_mask]
 
-    # Sum forces from all pairs
-    forces += np.sum(direction * force_magnitudes[:, :, None], axis=1)
-    forces -= np.sum(direction * force_magnitudes[:, :, None], axis=0)
+    # Apply forces on center positions (Newton's 3rd law)
+    forces += np.sum(direction * strength[:, :, None], axis=1)
+    forces -= np.sum(direction * strength[:, :, None], axis=0)
 
-    # Border corrective forces
+    # Boundary forces pushing centers inside if overlapping edges
     x, y = centers[:, 0], centers[:, 1]
     r = radii
 
-    # Left border
-    left_overlap = r - x
-    forces[:, 0] += np.where(left_overlap > 0, left_overlap, 0)
-    # Right border
-    right_overlap = (x + r) - 1
-    forces[:, 0] -= np.where(right_overlap > 0, right_overlap, 0)
-    # Bottom border
-    bottom_overlap = r - y
-    forces[:, 1] += np.where(bottom_overlap > 0, bottom_overlap, 0)
-    # Top border
-    top_overlap = (y + r) - 1
-    forces[:, 1] -= np.where(top_overlap > 0, top_overlap, 0)
+    # Left boundary
+    overlap_l = r - x
+    forces[:, 0] += np.where(overlap_l > 0, overlap_l ** 2, 0)
+    # Right boundary
+    overlap_r = (x + r) - 1
+    forces[:, 0] -= np.where(overlap_r > 0, overlap_r ** 2, 0)
+    # Bottom boundary
+    overlap_b = r - y
+    forces[:, 1] += np.where(overlap_b > 0, overlap_b ** 2, 0)
+    # Top boundary
+    overlap_t = (y + r) - 1
+    forces[:, 1] -= np.where(overlap_t > 0, overlap_t ** 2, 0)
 
     return forces
 
 def update_centers(centers, forces, alpha, momentum, prev_update):
-    """
-    Update centers with forces, step size alpha, and momentum.
-    """
     update = alpha * forces + momentum * prev_update
-    new_centers = centers + update
-    new_centers = np.clip(new_centers, 0.01, 0.99)
-    return new_centers, update
+    centers_new = centers + update
+    centers_new = np.clip(centers_new, 0.01, 0.99)
+    return centers_new, update
 
 def construct_packing():
-    """
-    Construct and optimize arrangement of 26 circles in unit square
-    using modular force-based inflate-and-relax algorithm.
-    Returns:
-        centers: np.array (26,2)
-        radii: np.array (26,)
-    """
+    np.random.seed(42)
     n = 26
-    centers = initialize_centers(n)
-    radii = compute_max_radii(centers)
 
-    alpha = 0.025
-    momentum = 0.5
-    prev_update = np.zeros_like(centers)
-    max_iters = 700
+    best_centers = None
+    best_radii = None
+    best_sum = -np.inf
 
-    for _ in range(max_iters):
-        forces = compute_forces(centers, radii)
-        centers, prev_update = update_centers(centers, forces, alpha, momentum, prev_update)
-        radii = compute_max_radii(centers)
-        alpha *= 0.997  # gradual decay for stability
+    # Explore candidate layouts adaptively
+    for rows in layout_candidates():
+        if sum(rows) != n:
+            continue
+        # Compute y positions for rows equally spaced with vertical margins
+        nrows = len(rows)
+        y_margin = 0.07
+        y_positions = np.linspace(y_margin, 1 - y_margin, nrows)
 
-    return centers, radii
+        centers_list = []
+        for i, count in enumerate(rows):
+            row_centers = hex_row_centers(count, y_positions[i], x_margin=0.05, width=0.9)
+            centers_list.append(row_centers)
+        centers = np.vstack(centers_list)
+
+        # Assign initial size gradient for radii adjustment, scaled slightly by row index factor
+        size_factor = assign_size_gradient(centers)
+
+        # Initial radii limit from borders and size gradient (scale base radius ~0.05 * size_factor)
+        base_radii = np.minimum.reduce([centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]])
+        radii = np.clip(base_radii, 0, None)
+        target_radii = 0.06 * size_factor
+        radii = np.minimum(radii, target_radii)
+
+        # Refine radii with repeated maximal tightening
+        radii = compute_max_radii(centers, max_iters=10)
+        # Initialize parameters for force relaxation
+        alpha = 0.03
+        momentum = 0.65
+        prev_update = np.zeros_like(centers)
+        max_iters = 800
+
+        # Adaptive iterative relaxation combining forces and radius tightening
+        for it in range(max_iters):
+            forces = compute_forces(centers, radii)
+            centers, prev_update = update_centers(centers, forces, alpha, momentum, prev_update)
+            prev_radii = radii.copy()
+            radii = compute_max_radii(centers, max_iters=5)
+
+            # Slightly bias radii upward towards size gradient target without overlap
+            radii = np.minimum(radii * 1.002, target_radii)
+
+            # Decay step size and momentum for stability in later iterations
+            alpha *= 0.9985
+            momentum *= 0.999
+
+            # Early stopping if improvement small after many iterations
+            if it > 400 and np.sum(np.abs(radii - prev_radii)) < 1e-6:
+                break
+
+        sum_radii = np.sum(radii)
+        if sum_radii > best_sum:
+            best_sum = sum_radii
+            best_centers = centers.copy()
+            best_radii = radii.copy()
+
+    return best_centers, best_radii
 
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii
