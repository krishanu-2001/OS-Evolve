# EVOLVE-BLOCK-START
import numpy as np

def layout_candidates():
    # Possible row splits summing to 26 circles
    # Focus on splits with <=7 circles per row, 4-6 rows total
    return [
        [6,5,6,5,4],
        [5,5,6,5,5],
        [5,6,5,6,4],
        [4,6,6,5,5],
        [6,6,5,5,4],
        [5,6,6,4,5]
    ]

def hex_row_centers(count, y, x_margin=0.05, y_margin=0.05, width=1.0):
    # Centers arranged with hex spacing along x at given y height
    # Use hex spacing: horizontal spacing = 2r, vertical spacing adjusted by sqrt(3)
    # Here generate equally spaced points with optional jitter
    if count == 1:
        return np.array([[width/2, y]])
    spacing = (width - 2*x_margin) / (count - 1) if count > 1 else 0
    xs = x_margin + np.arange(count) * spacing
    centers = np.stack([xs, np.full(count, y)], axis=1)
    # jitter on x slightly (up to 0.007) helps relaxation but small enough
    jitter = (np.random.rand(count) - 0.5) * 0.014
    centers[:,0] += jitter
    return centers

def assign_size_gradient(centers):
    # Assign target sizes with larger radii near center of square and center rows
    # Radius priority based on distance from center (0.5,0.5)
    # Use a Gaussian decay from center, emphasizing middle rows
    dist_center = np.linalg.norm(centers - 0.5, axis=1)
    # invert distance, normalize, and apply a softmax-like exponent for size gradient
    max_dist = np.sqrt(2*0.5**2)
    norm_dist = dist_center / max_dist
    # size factor (higher size when norm_dist low)
    size_factor = np.exp(- (norm_dist*4)**2)
    # normalize size_factor to max 1, min ~0.1
    size_factor = 0.1 + 0.9 * (size_factor - size_factor.min())/(size_factor.max() - size_factor.min() + 1e-10)
    return size_factor

def compute_max_radii(centers, max_iters=10):
    n = centers.shape[0]
    radii = np.minimum.reduce([centers[:,0], centers[:,1], 1 - centers[:,0], 1 - centers[:,1]])
    # Iterative tightening for pairwise constraints until convergence or max_iters
    for _ in range(max_iters):
        changed = False
        for i in range(n):
            for j in range(i+1, n):
                d = np.linalg.norm(centers[i]-centers[j])
                if d <= 1e-14:
                    continue # skip identical points just in case
                if radii[i] + radii[j] > d:
                    scale = d / (radii[i] + radii[j])
                    # Apply scale only if it reduces radii (strict monotonic)
                    if scale < 1.0 - 1e-8:
                        radii[i] *= scale
                        radii[j] *= scale
                        changed = True
        if not changed:
            break
    # Avoid tiny or zero radii
    radii = np.maximum(radii, 1e-6)
    return radii

def compute_forces(centers, radii):
    n = centers.shape[0]
    forces = np.zeros_like(centers)
    # Pairwise differences and distances
    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]  # shape (n,n,2)
    dist = np.linalg.norm(diff, axis=2) + np.eye(n)
    sum_r = radii[:, None] + radii[None, :]
    overlap = sum_r - dist
    overlap_mask = (overlap > 0) & (~np.eye(n, dtype=bool))

    # Direction: from j to i
    direction = np.zeros_like(diff)
    # Safely compute direction only where overlap
    direction[overlap_mask] = diff[overlap_mask] / dist[overlap_mask][:, None]

    # Repulsion proportional to overlap squared (stronger)
    strength = np.zeros_like(dist)
    strength[overlap_mask] = overlap[overlap_mask] ** 2 / dist[overlap_mask]

    # Apply forces on center positions (Newton's 3rd law)
    forces += np.sum(direction * strength[:, :, None], axis=1)
    forces -= np.sum(direction * strength[:, :, None], axis=0)

    # Boundary forces pushing centers inside if overlapping edges
    x, y = centers[:, 0], centers[:, 1]
    r = radii

    # Left boundary
    overlap_l = r - x
    forces[:, 0] += np.where(overlap_l > 0, overlap_l ** 2, 0)
    # Right boundary
    overlap_r = (x + r) - 1
    forces[:, 0] -= np.where(overlap_r > 0, overlap_r ** 2, 0)
    # Bottom boundary
    overlap_b = r - y
    forces[:, 1] += np.where(overlap_b > 0, overlap_b ** 2, 0)
    # Top boundary
    overlap_t = (y + r) - 1
    forces[:, 1] -= np.where(overlap_t > 0, overlap_t ** 2, 0)

    return forces

def update_centers(centers, forces, alpha, momentum, prev_update):
    update = alpha * forces + momentum * prev_update
    centers_new = centers + update
    centers_new = np.clip(centers_new, 0.01, 0.99)
    return centers_new, update

def construct_packing():
    np.random.seed(42)
    n = 26

    best_centers = None
    best_radii = None
    best_sum = -np.inf

    # Explore candidate layouts adaptively
    for rows in layout_candidates():
        if sum(rows) != n:
            continue
        # Compute y positions for rows equally spaced with vertical margins
        nrows = len(rows)
        y_margin = 0.07
        y_positions = np.linspace(y_margin, 1 - y_margin, nrows)

        centers_list = []
        for i, count in enumerate(rows):
            row_centers = hex_row_centers(count, y_positions[i], x_margin=0.05, width=0.9)
            centers_list.append(row_centers)
        centers = np.vstack(centers_list)

        # Assign initial size gradient for radii adjustment, scaled slightly by row index factor
        size_factor = assign_size_gradient(centers)

        # Initial radii limit from borders and size gradient (scale base radius ~0.05 * size_factor)
        base_radii = np.minimum.reduce([centers[:, 0], centers[:, 1], 1 - centers[:, 0], 1 - centers[:, 1]])
        radii = np.clip(base_radii, 0, None)
        target_radii = 0.06 * size_factor
        radii = np.minimum(radii, target_radii)

        # Refine radii with repeated maximal tightening
        radii = compute_max_radii(centers, max_iters=10)
        # Initialize parameters for force relaxation
        alpha = 0.03
        momentum = 0.65
        prev_update = np.zeros_like(centers)
        max_iters = 800

        # Adaptive iterative relaxation combining forces and radius tightening
        for it in range(max_iters):
            forces = compute_forces(centers, radii)
            centers, prev_update = update_centers(centers, forces, alpha, momentum, prev_update)
            prev_radii = radii.copy()
            radii = compute_max_radii(centers, max_iters=5)

            # Slightly bias radii upward towards size gradient target without overlap
            radii = np.minimum(radii * 1.002, target_radii)

            # Decay step size and momentum for stability in later iterations
            alpha *= 0.9985
            momentum *= 0.999

            # Early stopping if improvement small after many iterations
            if it > 400 and np.sum(np.abs(radii - prev_radii)) < 1e-6:
                break

        sum_radii = np.sum(radii)
        if sum_radii > best_sum:
            best_sum = sum_radii
            best_centers = centers.copy()
            best_radii = radii.copy()

    return best_centers, best_radii

# EVOLVE-BLOCK-END