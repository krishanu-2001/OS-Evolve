--- a/original.py
+++ b/original.py
@@ -1,189 +1,255 @@
 # EVOLVE-BLOCK-START
-"""Adaptive Greedy + Localized Global Sampling + Annealing + Final Repack for n=26"""
+"""Voronoi relaxation + evolutionary search for n=26 circle packing"""
 
 import numpy as np
+from scipy.spatial import Voronoi
 
 def construct_packing():
     """
-    Pack 26 circles in a unit square using diverse greedy initialization,
-    adaptive simulated annealing with multi-move perturbations, and a
-    final local greedy repack sweep.
+    Pack 26 circles in a unit square using Voronoi-based relaxation,
+    evolutionary search, and a final local greedy repack.
     Returns:
         centers: np.array (26,2)
         radii:   np.array (26,)
     """
     n = 26
+    pop_size = 16
+    generations = 60
+    relax_steps = 8
     rng = np.random.default_rng(42)
-    centers = []
-
-    # --- Phase 1: Seeding corners, midpoints, classic points ---
-    # 1. Four corners
-    corners = np.array([[0,0], [1,0], [1,1], [0,1]])
-    centers.extend(corners)
-
-    # 2. Center
-    centers.append([0.5, 0.5])
-
-    # 3. Midpoints of edges
-    mids = np.array([[0.5,0], [1,0.5], [0.5,1], [0,0.5]])
-    centers.extend(mids)
-
-    # 4. Quarter-edge points
-    q1 = np.array([[0.25,0],[0.75,0],[1,0.25],[1,0.75],[0.75,1],[0.25,1],[0,0.75],[0,0.25]])
-    centers.extend(q1)
-
-    # 5. Four inner grid points (for square/hex flexibility)
-    grid = np.array([[0.25,0.25],[0.75,0.25],[0.75,0.75],[0.25,0.75]])
-    centers.extend(grid)
-
-    # -- At this stage: 4 + 1 + 4 + 8 + 4 = 21 (5 to go)
-    centers = np.array(centers)
-    assert centers.shape[0] == 21
-
-    # --- Phase 2: Hybrid greedy fill (global + local) ---
-    num_to_add = n - len(centers)
-    gdiv = 3  # Number via global (largest gap), remainder by localized gap fill
-    new_pts = []
-    # 2.A Global: candidates sampled across the entire square
-    n_candidates = 1000
-    candidates = rng.uniform([0.05,0.05], [0.95,0.95], (n_candidates,2))
-    # avoid exact borders - robust packing
-    for _ in range(gdiv):
-        dists = np.min(np.linalg.norm(centers - candidates[:,None], axis=2), axis=1)
-        i = np.argmax(dists)
-        new_pts.append(candidates[i])
-        centers = np.vstack([centers, candidates[i]])
-        candidates = np.delete(candidates, i, axis=0)
-
-    # 2.B Local: sample candidates within R of existing circles, perturbing existing ones
-    Rloc = 0.22
-    for _ in range(num_to_add - gdiv):
-        local_centers = centers[rng.choice(len(centers), size=8, replace=False)]
-        jitter = rng.normal(0, Rloc*0.33, size=(8,2))
-        probe = np.clip(local_centers + jitter, 0.05, 0.95)
-        probe = np.vstack([probe, rng.uniform([0.15,0.15],[0.85,0.85],(8,2))])
-        dists = np.min(np.linalg.norm(centers - probe[:,None], axis=2), axis=1)
-        i = np.argmax(dists)
-        chosen = probe[i]
-        new_pts.append(chosen)
-        centers = np.vstack([centers, chosen])
-    centers = centers[:n]
-    centers = np.clip(centers, 0.0, 1.0)  # Stay in-bounds
-
-    # --- Phase 3: Compute initial radii ---
+
+    # --- Phase 1: Voronoi-seeded initialization ---
+    population = []
+    for _ in range(pop_size):
+        # Classic seeds: corners, center, edge midpoints, grid, plus randoms
+        centers = []
+        centers.extend([[0,0],[1,0],[1,1],[0,1],[0.5,0.5]])
+        centers.extend([[0.5,0],[1,0.5],[0.5,1],[0,0.5]])
+        centers.extend([[0.25,0.25],[0.75,0.25],[0.75,0.75],[0.25,0.75]])
+        # Fill up to n with random points
+        while len(centers) < n:
+            centers.append(rng.uniform(0.08,0.92,2))
+        centers = np.array(centers[:n])
+        # Voronoi relaxation to spread points
+        for _ in range(relax_steps):
+            centers = voronoi_relaxation(centers, bounds=(0,1,0,1))
+        population.append(centers)
+
+    # --- Phase 2: Evolutionary Voronoi Relaxation ---
+    fitness = np.zeros(pop_size)
+    radii_pop = [None]*pop_size
+    for gen in range(generations):
+        # Evaluate fitness (sum of radii)
+        for i in range(pop_size):
+            radii = compute_max_radii(population[i])
+            radii_pop[i] = radii
+            fitness[i] = np.sum(radii)
+        # Select elites
+        elite_idx = np.argsort(fitness)[-4:]
+        elites = [population[i].copy() for i in elite_idx]
+        # Generate new population
+        new_population = []
+        # Keep elites
+        for e in elites:
+            new_population.append(e.copy())
+        # Mutate elites
+        for e in elites:
+            c = e.copy()
+            idxs = rng.choice(n, size=rng.integers(2,6), replace=False)
+            c[idxs] += rng.normal(0, 0.07, size=(len(idxs),2))
+            c = np.clip(c, 0.01, 0.99)
+            # Voronoi relaxation
+            c = voronoi_relaxation(c, bounds=(0,1,0,1), steps=2)
+            new_population.append(c)
+        # Recombine pairs of elites
+        for _ in range(4):
+            a, b = rng.choice(len(elites), size=2, replace=False)
+            c = 0.5*elites[a] + 0.5*elites[b]
+            c += rng.normal(0, 0.03, size=c.shape)
+            c = np.clip(c, 0.01, 0.99)
+            c = voronoi_relaxation(c, bounds=(0,1,0,1), steps=1)
+            new_population.append(c)
+        # Add new randoms
+        for _ in range(pop_size - len(new_population)):
+            c = rng.uniform(0.08,0.92,(n,2))
+            c = voronoi_relaxation(c, bounds=(0,1,0,1), steps=relax_steps)
+            new_population.append(c)
+        population = new_population
+
+    # --- Phase 3: Final local greedy repack in Voronoi cells ---
+    # Pick best candidate
+    best_idx = np.argmax(fitness)
+    centers = population[best_idx].copy()
     radii = compute_max_radii(centers)
-
-    # --- Phase 4: Adaptive Simulated Annealing with occasional multi-move
-    best_centers = centers.copy()
-    best_radii   = radii.copy()
-    best_sum     = np.sum(radii)
-    curr_centers = centers.copy()
-    curr_radii   = radii.copy()
-    curr_sum     = best_sum
-
-    # Adaptive annealing parameters
-    T = 0.012
-    min_T = 1e-5
-    alpha = 0.997
-    stall_count = 0
-    for it in range(4800):
-        # Multi-move perturbations: choose 1-3 circles, nearby or random
-        if rng.uniform() < 0.14:
-            # Multi-move: choose a random pair of *close* indices (likely neighbors)
-            idxs = rng.choice(n, size=2, replace=False)
-            if np.linalg.norm(curr_centers[idxs[0]]-curr_centers[idxs[1]]) > 0.45:
-                idxs[1] = (idxs[0]+1)%n  # keep closer
-        else:
-            idxs = [rng.choice(n)]
-        trial = curr_centers.copy()
-        # Step scale decays with annealing temperature
-        scale = 0.031 * (T/0.012)**0.4
-        trial[idxs] += rng.normal(0, scale, size=(len(idxs),2))
-        trial = np.clip(trial, 0, 1)
-        trial_radii = compute_max_radii(trial)
-        if np.all(trial_radii > 1e-7):
-            trial_sum = np.sum(trial_radii)
-            dE = trial_sum - curr_sum
-            accept = False
-            if dE > 1e-9:
-                accept = True
-            elif rng.uniform() < np.exp(dE/T):  # classic annealing
-                accept = True
-            if accept:
-                curr_centers = trial
-                curr_radii = trial_radii
-                curr_sum = trial_sum
-                stall_count = 0
-                if curr_sum > best_sum + 1e-9:
-                    best_sum = curr_sum
-                    best_centers = curr_centers.copy()
-                    best_radii = curr_radii.copy()
-            else:
-                stall_count += 1
-        else:
-            stall_count += 1
-        # Adaptive: if stuck, drop T a bit faster
-        if stall_count >= 40 and T > min_T:
-            T *= alpha ** 2.5  # faster decay in stalling
-            stall_count = 0
-        else:
-            T *= alpha
-
-    # --- Phase 5: Greedy repack sweep (locally maximize each) ---
-    centers = best_centers.copy()
-    radii   = best_radii.copy()
-    for repack_pass in range(3):
+    for _ in range(3):
+        # For each circle, move to best spot in its Voronoi cell
+        vor = bounded_voronoi(centers, bounds=(0,1,0,1))
         for i in range(n):
-            others = np.delete(centers, i, axis=0)
-            # Probe dozens of candidate positions within 0.11 of current
-            probes = centers[i] + rng.uniform(-0.11, 0.11, (32,2))
-            probes = np.clip(probes, 0.01, 0.99)
-            # Include current location
-            probes = np.vstack([probes, centers[i]])
-            max_rad = 0.
-            best_probe = centers[i]
-            for p in probes:
+            cell = vor[i]
+            if len(cell) < 3:
+                continue
+            # Sample points in cell
+            pts = sample_polygon(cell, 24, rng)
+            pts = np.vstack([pts, centers[i]])
+            best_r = 0
+            best_p = centers[i]
+            for p in pts:
                 border_r = min(p[0],p[1],1-p[0],1-p[1])
-                sep = np.linalg.norm(others - p, axis=1)
+                sep = np.linalg.norm(np.delete(centers,i,axis=0) - p, axis=1)
                 safe_sep = sep.min() if len(sep)>0 else border_r
                 cand_r = min(border_r, safe_sep)
-                if cand_r > max_rad:
-                    max_rad = cand_r
-                    best_probe = p
-            centers[i] = best_probe
+                if cand_r > best_r:
+                    best_r = cand_r
+                    best_p = p
+            centers[i] = best_p
         radii = compute_max_radii(centers)
 
     return centers, radii
 
+def voronoi_relaxation(centers, bounds, steps=1):
+    """Move each center to centroid of its bounded Voronoi cell."""
+    for _ in range(steps):
+        vor = bounded_voronoi(centers, bounds)
+        for i, cell in enumerate(vor):
+            if len(cell) < 3:
+                continue
+            centers[i] = polygon_centroid(cell)
+        centers = np.clip(centers, bounds[0]+1e-3, bounds[1]-1e-3)
+    return centers
+
+def bounded_voronoi(points, bounds):
+    """
+    Compute bounded Voronoi cells for points in [xmin,xmax,ymin,ymax].
+    Returns: list of polygons (each a list of (x,y) points).
+    """
+    # Pad with mirrored points to bound the diagram
+    xmin, xmax, ymin, ymax = bounds
+    pts = points
+    # Mirror points at boundaries
+    mirror = []
+    for dx in [-1,0,1]:
+        for dy in [-1,0,1]:
+            if dx==0 and dy==0: continue
+            mirror.append(pts + np.array([dx*(xmax-xmin), dy*(ymax-ymin)]))
+    allpts = np.vstack([pts]+mirror)
+    vor = Voronoi(allpts)
+    # For each original point, clip its region to the box
+    regions = []
+    for i in range(len(pts)):
+        region_idx = vor.point_region[i]
+        region = vor.regions[region_idx]
+        if -1 in region or len(region)==0:
+            # Unbounded, fallback to box
+            regions.append(np.array([
+                [xmin,ymin],[xmax,ymin],[xmax,ymax],[xmin,ymax]
+            ]))
+            continue
+        poly = np.array([vor.vertices[v] for v in region])
+        # Clip to box
+        poly = clip_polygon(poly, xmin, xmax, ymin, ymax)
+        regions.append(poly)
+    return regions
+
+def clip_polygon(poly, xmin, xmax, ymin, ymax):
+    """Sutherlandâ€“Hodgman polygon clipping to box."""
+    def clip_edge(poly, edge):
+        out = []
+        for i in range(len(poly)):
+            A, B = poly[i-1], poly[i]
+            if edge(B):
+                if not edge(A):
+                    # Intersect
+                    out.append(intersect(A,B,edge))
+                out.append(B)
+            elif edge(A):
+                out.append(intersect(A,B,edge))
+        return np.array(out) if len(out)>0 else np.array([])
+    def left(p): return p[0]>=xmin
+    def right(p): return p[0]<=xmax
+    def bottom(p): return p[1]>=ymin
+    def top(p): return p[1]<=ymax
+    def intersect(A,B,edge):
+        # Find intersection of AB with the edge
+        x1,y1 = A; x2,y2 = B
+        if edge==left:
+            x = xmin
+            y = y1 + (y2-y1)*(xmin-x1)/(x2-x1+1e-12)
+        elif edge==right:
+            x = xmax
+            y = y1 + (y2-y1)*(xmax-x1)/(x2-x1+1e-12)
+        elif edge==bottom:
+            y = ymin
+            x = x1 + (x2-x1)*(ymin-y1)/(y2-y1+1e-12)
+        elif edge==top:
+            y = ymax
+            x = x1 + (x2-x1)*(ymax-y1)/(y2-y1+1e-12)
+        return np.array([x,y])
+    for edge in [left, right, bottom, top]:
+        poly = clip_edge(poly, edge)
+        if len(poly)==0:
+            break
+    return poly
+
+def polygon_centroid(poly):
+    """Centroid of a polygon (2D array of points)."""
+    x = poly[:,0]
+    y = poly[:,1]
+    a = 0.5*np.sum(x[:-1]*y[1:] - x[1:]*y[:-1])
+    if abs(a)<1e-12:
+        return np.mean(poly,axis=0)
+    cx = np.sum((x[:-1]+x[1:])*(x[:-1]*y[1:]-x[1:]*y[:-1]))/(6*a)
+    cy = np.sum((y[:-1]+y[1:])*(x[:-1]*y[1:]-x[1:]*y[:-1]))/(6*a)
+    return np.array([cx,cy])
+
+def sample_polygon(poly, n, rng):
+    """Uniformly sample n points inside a convex polygon."""
+    # Triangulate from centroid
+    centroid = np.mean(poly,axis=0)
+    pts = []
+    for i in range(len(poly)):
+        a = poly[i-1]
+        b = poly[i]
+        for _ in range(n//len(poly)+1):
+            r1, r2 = rng.uniform(0,1,2)
+            if r1+r2>1:
+                r1, r2 = 1-r1, 1-r2
+            p = (1-r1-r2)*centroid + r1*a + r2*b
+            pts.append(p)
+    pts = np.array(pts)[:n]
+    return pts
+
 def compute_max_radii(centers):
+    """
+    Given circle centers, compute the maximal non-overlapping radii
+    within the unit square by iterative constraint enforcement.
+    """
     n = centers.shape[0]
     xs, ys = centers[:,0], centers[:,1]
-    # Initial border constraints
     radii = np.minimum.reduce([xs, ys, 1-xs, 1-ys])
-    # Improve by iteratively reducing radii on overlaps
-    for _ in range(24):
+    # Iteratively enforce pairwise non-overlap
+    for _ in range(20):
         changed = False
         for i in range(n):
             for j in range(i+1, n):
                 d = np.linalg.norm(centers[i]-centers[j])
                 if radii[i]+radii[j] > d:
-                    scale = d/(radii[i]+radii[j]+1e-14)
+                    scale = d/(radii[i]+radii[j]+1e-12)
                     oldi, oldj = radii[i], radii[j]
                     radii[i] *= scale
                     radii[j] *= scale
                     if abs(radii[i]-oldi)>1e-10 or abs(radii[j]-oldj)>1e-10:
                         changed = True
         if not changed:
             break
     radii = np.clip(radii, 1e-7, 0.5)
     return radii
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii
