--- a/original.py
+++ b/original.py
@@ -1,154 +1,148 @@
 # EVOLVE-BLOCK-START
 import numpy as np
 import math
 
-def greedy_initial(n, samples=8000, seed=0):
-    """
-    Sequentially place n circles.
-    At each step, sample 'samples' random points and pick the one
-    with the largest feasible radius given existing circles.
-    """
+def max_radius_pt(p, centers, radii):
+    "Max feasible radius at point p given existing circles and walls."
+    r = min(p[0], p[1], 1-p[0], 1-p[1])
+    if len(centers)>0:
+        arr = np.array(centers)
+        dr = np.linalg.norm(arr - p, axis=1) - np.array(radii)
+        r = min(r, dr.min())
+    return max(r, 0.0)
+
+def greedy_hybrid(n, global_samples=5000, local_samples=2000, local_k=10, seed=0):
     rnd = np.random.RandomState(seed)
-    centers = []
-    radii = []
+    centers, radii = [], []
     for k in range(n):
-        pts = rnd.rand(samples,2)
-        best_r = -1.0
-        best_p = None
-        if k == 0:
-            # for first circle just pick the best by walls
-            xs = pts[:,0]; ys = pts[:,1]
-            rs = np.minimum.reduce([xs, ys, 1-xs, 1-ys])
-            idx = np.argmax(rs)
-            best_r = rs[idx]; best_p = pts[idx]
-        else:
-            arr_centers = np.array(centers)
-            arr_radii = np.array(radii)
-            for p in pts:
-                # radius limited by walls
-                r = min(p[0], p[1], 1-p[0], 1-p[1])
-                # limit by existing circles
-                d = np.linalg.norm(arr_centers - p, axis=1) - arr_radii
-                r = min(r, d.min())
-                if r > best_r:
-                    best_r = r; best_p = p
+        # global sampling
+        pts = rnd.rand(global_samples,2)
+        rs = np.minimum.reduce([pts[:,0], pts[:,1], 1-pts[:,0], 1-pts[:,1]])
+        if k>0:
+            arr_c = np.array(centers); arr_r = np.array(radii)
+            dmat = np.linalg.norm(arr_c[None,:,:]-pts[:,None,:], axis=2) - arr_r
+            rs = np.minimum(rs, dmat.min(axis=1))
+        idx = np.argmax(rs)
+        best_p, best_r = pts[idx], rs[idx]
+        # local gap-biased sampling
+        for _ in range(local_k):
+            p = best_p + rnd.randn(2)*best_r*0.5
+            p = np.clip(p, 0.0, 1.0)
+            r = max_radius_pt(p, centers, radii)
+            if r > best_r:
+                best_r, best_p = r, p
         centers.append(best_p)
-        radii.append(max(best_r, 1e-6))
+        radii.append(max(best_r, 1e-8))
     return np.array(centers), np.array(radii)
 
 def compute_radius_at(i, centers, radii):
-    """
-    Given center i, compute its maximal radius not overlapping others or walls.
-    """
     x,y = centers[i]
-    # wall limit
-    r = min(x, y, 1-x, 1-y)
-    if len(centers) > 1:
-        # exclude self
+    r = min(x,y,1-x,1-y)
+    n = centers.shape[0]
+    if n>1:
         others = np.delete(centers, i, axis=0)
-        rads  = np.delete(radii, i)
-        d = np.linalg.norm(others - centers[i], axis=1) - rads
+        rr = np.delete(radii, i)
+        d = np.linalg.norm(others - centers[i], axis=1) - rr
         r = min(r, d.min())
     return max(r, 0.0)
 
-def simulated_annealing(centers, radii, iters=12000, T0=0.1, Tend=1e-4, seed=1):
-    """
-    Refine the placement by simulated annealing: perturb one or multiple circles at a time,
-    recompute their max radii, and accept moves that improve total radius or
-    stochastically based on temperature.
-    """
+def adaptive_anneal(centers, radii, iters=20000, T0=0.1, Tmin=1e-6, seed=1):
     rnd = np.random.RandomState(seed)
     n = centers.shape[0]
-    best_centers = centers.copy()
-    best_radii  = radii.copy()
-    best_sum = radii.sum()
-
-    curr_centers = centers.copy()
-    curr_radii = radii.copy()
-    curr_sum = best_sum
-    T = T0
-    decay = (Tend/T0)**(1.0/iters)
-
-    multi_prob = 0.05
-    multi_count = 3
-    step_scale = 0.02
-
+    curr_c, curr_r = centers.copy(), radii.copy()
+    curr_sum = curr_r.sum()
+    best_c, best_r, best_sum = curr_c.copy(), curr_r.copy(), curr_sum
+    T = T0; decay = (Tmin/T0)**(1.0/iters)
+    no_improve = 0
+    multi_prob, multi_cnt = 0.1, 3
     for it in range(iters):
         if rnd.rand() < multi_prob:
-            # multi-circle perturbation
-            idxs = rnd.choice(n, multi_count, replace=False)
-            old_ps = curr_centers[idxs].copy()
-            old_rs = curr_radii[idxs].copy()
-            steps = rnd.randn(multi_count, 2) * step_scale
-            new_ps = old_ps + steps
-            new_ps = np.clip(new_ps, 0.0, 1.0)
-            curr_centers[idxs] = new_ps
-            new_rs = np.array([compute_radius_at(i, curr_centers, curr_radii) for i in idxs])
-            if (new_rs > 1e-8).all():
-                new_sum = curr_sum - old_rs.sum() + new_rs.sum()
-                delta = new_sum - curr_sum
-                if delta >= 0 or rnd.rand() < math.exp(delta / T):
-                    curr_radii[idxs] = new_rs
-                    curr_sum = new_sum
-                    if curr_sum > best_sum:
-                        best_sum = curr_sum
-                        best_centers[:] = curr_centers
-                        best_radii[:] = curr_radii
+            idx = rnd.choice(n, multi_cnt, replace=False)
+        else:
+            idx = [rnd.randint(n)]
+        old_ps = curr_c[idx].copy(); old_rs = curr_r[idx].copy()
+        step = rnd.randn(len(idx),2) * (0.02 * math.sqrt(T/T0))
+        new_ps = np.clip(old_ps + step, 0.0, 1.0)
+        curr_c[idx] = new_ps
+        new_rs = np.array([compute_radius_at(i, curr_c, curr_r) for i in idx])
+        if (new_rs > 1e-8).all():
+            new_sum = curr_sum - old_rs.sum() + new_rs.sum()
+            dE = new_sum - curr_sum
+            if dE>0 or rnd.rand() < math.exp(dE/T):
+                curr_r[idx], curr_sum = new_rs, new_sum
+                if curr_sum > best_sum:
+                    best_sum, best_c, best_r = curr_sum, curr_c.copy(), curr_r.copy()
+                    no_improve = 0
                 else:
-                    curr_centers[idxs] = old_ps
+                    no_improve += 1
             else:
-                curr_centers[idxs] = old_ps
+                curr_c[idx] = old_ps
+                no_improve += 1
         else:
-            # single-circle perturbation
-            i = rnd.randint(n)
-            old_p = curr_centers[i].copy()
-            old_r = curr_radii[i]
-            step = rnd.randn(2) * step_scale
-            new_p = old_p + step
-            new_p = np.clip(new_p, 0.0, 1.0)
-            curr_centers[i] = new_p
-            new_r = compute_radius_at(i, curr_centers, curr_radii)
-            if new_r <= 1e-8:
-                curr_centers[i] = old_p
-            else:
-                new_sum = curr_sum - old_r + new_r
-                delta = new_sum - curr_sum
-                if delta >= 0 or rnd.rand() < math.exp(delta / T):
-                    curr_radii[i] = new_r
-                    curr_sum = new_sum
-                    if curr_sum > best_sum:
-                        best_sum = curr_sum
-                        best_centers[:] = curr_centers
-                        best_radii[:] = curr_radii
-                else:
-                    curr_centers[i] = old_p
-        T *= decay
+            curr_c[idx] = old_ps
+            no_improve += 1
+        # adaptive cooling
+        if no_improve < 50:
+            T *= decay * 1.01
+        else:
+            T *= decay * 0.9
+        T = max(T, Tmin)
+    return best_c, best_r
 
-    return best_centers, best_radii
+def local_repack(centers, radii, samples=300, sweeps=2, seed=123):
+    rnd = np.random.RandomState(seed)
+    n = centers.shape[0]
+    for _ in range(sweeps):
+        for i in range(n):
+            best_p, best_r = centers[i].copy(), radii[i]
+            for _ in range(samples):
+                p = centers[i] + rnd.randn(2)*best_r*0.3
+                p = np.clip(p,0.0,1.0)
+                r = max_radius_pt(p, np.delete(centers,i,axis=0).tolist(),
+                                    np.delete(radii,i).tolist())
+                if r > best_r:
+                    best_r, best_p = r, p
+            centers[i], radii[i] = best_p, best_r
+    return centers, radii
+
+def repulsive_refine(centers, radii, iters=50, lr=0.005):
+    c = centers.copy(); n = c.shape[0]
+    for _ in range(iters):
+        r = np.array([compute_radius_at(i,c,radii) for i in range(n)])
+        forces = np.zeros_like(c)
+        diff = c[:,None,:] - c[None,:,:]
+        dist = np.linalg.norm(diff,axis=2) + np.eye(n)
+        overlap = (r[:,None]+r[None,:]) - dist
+        mask = overlap>0
+        dirs = np.zeros_like(diff)
+        nonz = dist>0
+        dirs[nonz] = diff[nonz]/dist[nonz][...,None]
+        f = (overlap[...,None]*dirs)
+        forces -= f.sum(axis=1) - f.sum(axis=0)
+        # border forces
+        forces[:,0] += np.where(c[:,0]<r, r-c[:,0], 0) - np.where(1-c[:,0]<r, r-(1-c[:,0]),0)
+        forces[:,1] += np.where(c[:,1]<r, r-c[:,1], 0) - np.where(1-c[:,1]<r, r-(1-c[:,1]),0)
+        c += lr * forces
+        c = np.clip(c,0.0,1.0)
+    # recompute radii once at end
+    r_final = np.array([compute_radius_at(i,c,radii) for i in range(n)])
+    return c, r_final
 
 def construct_packing():
-    """
-    Build and optimize 26-circle packing via greedy initialization
-    followed by simulated annealing refinement.
-    """
     n = 26
-    # Phase 1: greedy placement
-    centers, radii = greedy_initial(n, samples=8000, seed=42)
-    # Phase 2: simulated annealing
-    centers, radii = simulated_annealing(centers, radii,
-                                         iters=15000,
-                                         T0=0.05,
-                                         Tend=1e-5,
-                                         seed=999)
-    return centers, radii
-
+    c, r = greedy_hybrid(n, global_samples=5000,
+                         local_samples=2000, local_k=10, seed=42)
+    c, r = adaptive_anneal(c, r, iters=20000, T0=0.1, Tmin=1e-6, seed=999)
+    c, r = local_repack(c, r, samples=300, sweeps=2, seed=314)
+    c, r = repulsive_refine(c, r, iters=50, lr=0.005)
+    return c, r
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii