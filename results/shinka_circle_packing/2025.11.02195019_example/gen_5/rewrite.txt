# EVOLVE-BLOCK-START
"""Hybrid hexagonal initialization + hill‐climbing for n=26 circle packing"""

import numpy as np

def construct_packing():
    """
    Initialize 26 circle centers on a hexagonal lattice, then perform
    a hill-climbing local search to maximize the sum of radii.
    Returns:
        centers: np.array (26,2)
        radii:   np.array (26,)
    """
    n = 26
    # Row layout: sums to 26
    row_counts = [6, 5, 6, 5, 4]
    max_cols = max(row_counts)
    margin = 0.02
    dx = (1 - 2*margin) / max_cols
    h  = dx * np.sqrt(3) / 2

    # Build initial hex grid
    centers = np.zeros((n, 2))
    idx = 0
    for rid, cnt in enumerate(row_counts):
        x_start = margin + (max_cols - cnt) * dx / 2
        y = margin + rid * h
        for c in range(cnt):
            centers[idx, 0] = x_start + c * dx
            centers[idx, 1] = y
            idx += 1

    # Compute initial radii & sum
    best_centers = centers.copy()
    best_radii   = compute_max_radii(best_centers)
    best_sum     = best_radii.sum()

    # Hill‐climbing parameters
    iters = 5000
    initial_alpha = dx * 0.5
    rng = np.random.default_rng(42)

    for t in range(iters):
        # decaying step size
        alpha = initial_alpha * (1 - t / iters)
        i = int(rng.integers(n))
        cand_centers = best_centers.copy()
        # random perturbation
        delta = rng.uniform(-alpha, alpha, size=2)
        cand_centers[i] += delta
        # keep inside margins
        cand_centers[i] = np.clip(cand_centers[i], margin, 1 - margin)
        # recompute radii & evaluate
        cand_radii = compute_max_radii(cand_centers)
        s = cand_radii.sum()
        if s > best_sum:
            best_sum     = s
            best_centers = cand_centers
            best_radii   = cand_radii

    return best_centers, best_radii


def compute_max_radii(centers):
    """
    Given circle centers, compute the maximal non-overlapping radii
    within the unit square by iteratively enforcing border and pairwise constraints.
    """
    n = centers.shape[0]
    radii = np.minimum.reduce([
        centers[:,0],            # distance to left
        centers[:,1],            # distance to bottom
        1 - centers[:,0],        # right
        1 - centers[:,1]         # top
    ])

    # Enforce non-overlap: for each pair, if sum > dist, scale both
    for i in range(n):
        for j in range(i+1, n):
            d = np.hypot(*(centers[i] - centers[j]))
            if d <= 0:
                # coincident centers — collapse both
                radii[i] = radii[j] = 0.0
            else:
                ri, rj = radii[i], radii[j]
                if ri + rj > d:
                    scale = d / (ri + rj)
                    radii[i] *= scale
                    radii[j] *= scale
    return radii

# EVOLVE-BLOCK-END


# This part remains fixed (not evolved)
def run_packing():
    """Run the circle packing constructor for n=26"""
    centers, radii = construct_packing()
    sum_radii = np.sum(radii)
    return centers, radii, sum_radii