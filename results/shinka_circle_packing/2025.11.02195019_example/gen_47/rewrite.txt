# EVOLVE-BLOCK-START
"""Adaptive Greedy + Localized Global Sampling + Annealing + Final Repack for n=26"""

import numpy as np

def construct_packing():
    """
    Pack 26 circles in a unit square using diverse greedy initialization,
    adaptive simulated annealing with multi-move perturbations, and a
    final local greedy repack sweep.
    Returns:
        centers: np.array (26,2)
        radii:   np.array (26,)
    """
    n = 26
    rng = np.random.default_rng(42)
    centers = []

    # --- Phase 1: Seeding corners, midpoints, classic points ---
    # 1. Four corners
    corners = np.array([[0,0], [1,0], [1,1], [0,1]])
    centers.extend(corners)

    # 2. Center
    centers.append([0.5, 0.5])

    # 3. Midpoints of edges
    mids = np.array([[0.5,0], [1,0.5], [0.5,1], [0,0.5]])
    centers.extend(mids)

    # 4. Quarter-edge points
    q1 = np.array([[0.25,0],[0.75,0],[1,0.25],[1,0.75],[0.75,1],[0.25,1],[0,0.75],[0,0.25]])
    centers.extend(q1)

    # 5. Four inner grid points (for square/hex flexibility)
    grid = np.array([[0.25,0.25],[0.75,0.25],[0.75,0.75],[0.25,0.75]])
    centers.extend(grid)

    # -- At this stage: 4 + 1 + 4 + 8 + 4 = 21 (5 to go)
    centers = np.array(centers)
    assert centers.shape[0] == 21

    # --- Phase 2: Hybrid greedy fill (global + local) ---
    num_to_add = n - len(centers)
    gdiv = 3  # Number via global (largest gap), remainder by localized gap fill
    new_pts = []
    # 2.A Global: candidates sampled across the entire square
    n_candidates = 1000
    candidates = rng.uniform([0.05,0.05], [0.95,0.95], (n_candidates,2))
    # avoid exact borders - robust packing
    for _ in range(gdiv):
        dists = np.min(np.linalg.norm(centers - candidates[:,None], axis=2), axis=1)
        i = np.argmax(dists)
        new_pts.append(candidates[i])
        centers = np.vstack([centers, candidates[i]])
        candidates = np.delete(candidates, i, axis=0)

    # 2.B Local: sample candidates within R of existing circles, perturbing existing ones
    Rloc = 0.22
    for _ in range(num_to_add - gdiv):
        local_centers = centers[rng.choice(len(centers), size=8, replace=False)]
        jitter = rng.normal(0, Rloc*0.33, size=(8,2))
        probe = np.clip(local_centers + jitter, 0.05, 0.95)
        probe = np.vstack([probe, rng.uniform([0.15,0.15],[0.85,0.85],(8,2))])
        dists = np.min(np.linalg.norm(centers - probe[:,None], axis=2), axis=1)
        i = np.argmax(dists)
        chosen = probe[i]
        new_pts.append(chosen)
        centers = np.vstack([centers, chosen])
    centers = centers[:n]
    centers = np.clip(centers, 0.0, 1.0)  # Stay in-bounds

    # --- Phase 3: Compute initial radii ---
    radii = compute_max_radii(centers)

    # --- Phase 4: Adaptive Simulated Annealing with occasional multi-move
    best_centers = centers.copy()
    best_radii   = radii.copy()
    best_sum     = np.sum(radii)
    curr_centers = centers.copy()
    curr_radii   = radii.copy()
    curr_sum     = best_sum

    # Adaptive annealing parameters
    T = 0.012
    min_T = 1e-5
    alpha = 0.997
    stall_count = 0
    for it in range(4800):
        # Multi-move perturbations: choose 1-3 circles, nearby or random
        if rng.uniform() < 0.14:
            # Multi-move: choose a random pair of *close* indices (likely neighbors)
            idxs = rng.choice(n, size=2, replace=False)
            if np.linalg.norm(curr_centers[idxs[0]]-curr_centers[idxs[1]]) > 0.45:
                idxs[1] = (idxs[0]+1)%n  # keep closer
        else:
            idxs = [rng.choice(n)]
        trial = curr_centers.copy()
        # Step scale decays with annealing temperature
        scale = 0.031 * (T/0.012)**0.4
        trial[idxs] += rng.normal(0, scale, size=(len(idxs),2))
        trial = np.clip(trial, 0, 1)
        trial_radii = compute_max_radii(trial)
        if np.all(trial_radii > 1e-7):
            trial_sum = np.sum(trial_radii)
            dE = trial_sum - curr_sum
            accept = False
            if dE > 1e-9:
                accept = True
            elif rng.uniform() < np.exp(dE/T):  # classic annealing
                accept = True
            if accept:
                curr_centers = trial
                curr_radii = trial_radii
                curr_sum = trial_sum
                stall_count = 0
                if curr_sum > best_sum + 1e-9:
                    best_sum = curr_sum
                    best_centers = curr_centers.copy()
                    best_radii = curr_radii.copy()
            else:
                stall_count += 1
        else:
            stall_count += 1
        # Adaptive: if stuck, drop T a bit faster
        if stall_count >= 40 and T > min_T:
            T *= alpha ** 2.5  # faster decay in stalling
            stall_count = 0
        else:
            T *= alpha

    # --- Phase 5: Greedy repack sweep (locally maximize each) ---
    centers = best_centers.copy()
    radii   = best_radii.copy()
    for repack_pass in range(3):
        for i in range(n):
            others = np.delete(centers, i, axis=0)
            # Probe dozens of candidate positions within 0.11 of current
            probes = centers[i] + rng.uniform(-0.11, 0.11, (32,2))
            probes = np.clip(probes, 0.01, 0.99)
            # Include current location
            probes = np.vstack([probes, centers[i]])
            max_rad = 0.
            best_probe = centers[i]
            for p in probes:
                border_r = min(p[0],p[1],1-p[0],1-p[1])
                sep = np.linalg.norm(others - p, axis=1)
                safe_sep = sep.min() if len(sep)>0 else border_r
                cand_r = min(border_r, safe_sep)
                if cand_r > max_rad:
                    max_rad = cand_r
                    best_probe = p
            centers[i] = best_probe
        radii = compute_max_radii(centers)

    return centers, radii

def compute_max_radii(centers):
    n = centers.shape[0]
    xs, ys = centers[:,0], centers[:,1]
    # Initial border constraints
    radii = np.minimum.reduce([xs, ys, 1-xs, 1-ys])
    # Improve by iteratively reducing radii on overlaps
    for _ in range(24):
        changed = False
        for i in range(n):
            for j in range(i+1, n):
                d = np.linalg.norm(centers[i]-centers[j])
                if radii[i]+radii[j] > d:
                    scale = d/(radii[i]+radii[j]+1e-14)
                    oldi, oldj = radii[i], radii[j]
                    radii[i] *= scale
                    radii[j] *= scale
                    if abs(radii[i]-oldi)>1e-10 or abs(radii[j]-oldj)>1e-10:
                        changed = True
        if not changed:
            break
    radii = np.clip(radii, 1e-7, 0.5)
    return radii
# EVOLVE-BLOCK-END


# This part remains fixed (not evolved)
def run_packing():
    """Run the circle packing constructor for n=26"""
    centers, radii = construct_packing()
    # Calculate the sum of radii
    sum_radii = np.sum(radii)
    return centers, radii, sum_radii