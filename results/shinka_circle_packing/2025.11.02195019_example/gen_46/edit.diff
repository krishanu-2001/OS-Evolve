--- a/original.py
+++ b/original.py
@@ -1,103 +1,104 @@
 # EVOLVE-BLOCK-START
-"""Greedy corner/edge seeded local search circle packing for n=26"""
+"""CMA-ES-inspired global optimization for circle packing (n=26)"""
 
 import numpy as np
 
 def construct_packing():
-    """
-    Place 26 circles in a unit square by greedy seeding at corners/edges,
-    then iteratively filling largest gaps, followed by local search.
-    Returns:
-        centers: np.array (26,2)
-        radii:   np.array (26,)
-    """
     n = 26
-    centers = []
-    # 1. Place 4 corners
-    corners = np.array([[0,0],[1,0],[1,1],[0,1]])
-    centers.extend(corners)
-    # 2. Place center
-    centers.append([0.5,0.5])
-    # 3. Place edge midpoints
-    edges = np.array([[0.5,0],[1,0.5],[0.5,1],[0,0.5]])
-    centers.extend(edges)
-    # 4. Place quarter-edge points (between center and corners)
-    q1 = np.array([[0.25,0],[0.75,0],[1,0.25],[1,0.75],[0.75,1],[0.25,1],[0,0.75],[0,0.25]])
-    centers.extend(q1)
-    # 5. Place 5 more: at 0.25,0.75 grid inside
-    grid = np.array([[0.25,0.25],[0.75,0.25],[0.75,0.75],[0.25,0.75],[0.5,0.25]])
-    centers.extend(grid)
-    centers = np.array(centers)[:n]
+    D = 2 * n
 
-    # 6. Greedy fill: for any remaining, place at largest empty spot
-    while len(centers) < n:
-        # Find a grid of candidate points, pick the one with largest min distance to existing
-        candidates = np.random.rand(200,2)
-        dists = np.array([np.min(np.linalg.norm(centers - c, axis=1)) for c in candidates])
-        idx = np.argmax(dists)
-        centers = np.vstack([centers, candidates[idx]])
+    # 1) Initialize mean at a hexagonal-lattice pattern interior to [0,1]^2
+    row_counts = [6, 5, 6, 5, 4]
+    margin = 0.1
+    max_row = max(row_counts)
+    dx = (1 - 2 * margin) / (max_row - 1)
+    dy = dx * np.sqrt(3) / 2
+    centers0 = []
+    for i, cnt in enumerate(row_counts):
+        y = margin + i * dy
+        x0 = margin + (max_row - cnt) * dx / 2
+        for j in range(cnt):
+            centers0.append([x0 + j * dx, y])
+    centers0 = np.array(centers0[:n])
+    mean = centers0.flatten()
 
-    # 7. Compute initial radii
+    # 2) Evolution Strategy parameters
+    pop = 30                  # population size
+    mu = pop // 2             # number of elites
+    generations = 120
+    sigma = 0.1               # initial step size
+    # log‐weights for recombination
+    weights = np.log(mu + 0.5) - np.log(np.arange(1, mu + 1))
+    weights /= np.sum(weights)
+
+    rng = np.random.default_rng(123)
+    best_f = -np.inf
+    best_x = mean.copy()
+
+    # 3) Main ES loop: sample, evaluate, select, recombine, step‐size decay
+    for gen in range(generations):
+        # Sample candidate solutions
+        pop_sols = mean + sigma * rng.standard_normal((pop, D))
+        pop_sols = np.clip(pop_sols, 0.0, 1.0)
+
+        fitness = np.zeros(pop)
+        for k in range(pop):
+            c = pop_sols[k].reshape(n, 2)
+            r = compute_max_radii(c)
+            fitness[k] = np.sum(r)
+            if fitness[k] > best_f:
+                best_f = fitness[k]
+                best_x = pop_sols[k].copy()
+
+        # Select top‐mu and recombine to update mean
+        elite_idx = np.argsort(fitness)[-mu:]
+        elite = pop_sols[elite_idx]
+        mean = (weights[:, None] * elite).sum(axis=0)
+
+        # Gradually reduce step size
+        sigma *= 0.99
+
+    # 4) Return the best candidate found
+    centers = best_x.reshape(n, 2)
     radii = compute_max_radii(centers)
-
-    # 8. Local search: perturb centers to increase sum of radii
-    best_centers = centers.copy()
-    best_radii = radii.copy()
-    best_sum = np.sum(radii)
-    np.random.seed(42)
-    for it in range(4000):
-        # Adaptive: sometimes move 1, sometimes 2, sometimes 3
-        k = np.random.choice([1,2,3], p=[0.7,0.2,0.1])
-        idxs = np.random.choice(n, k, replace=False)
-        trial = centers.copy()
-        # Small random move, scale decays with iterations
-        scale = 0.04 * (0.995**it)
-        trial[idxs] += (np.random.randn(k,2)) * scale
-        # Keep in bounds
-        trial = np.clip(trial, 0, 1)
-        # Recompute radii
-        trial_radii = compute_max_radii(trial)
-        # Accept if strictly non-overlapping and sum improves
-        if np.all(trial_radii > 1e-6):
-            if np.sum(trial_radii) > best_sum + 1e-8:
-                centers = trial
-                radii = trial_radii
-                best_centers = trial.copy()
-                best_radii = trial_radii.copy()
-                best_sum = np.sum(trial_radii)
-    return best_centers, best_radii
+    return centers, radii
 
 def compute_max_radii(centers):
     """
-    For fixed centers, compute max radii so circles stay in [0,1]^2 and don't overlap.
-    Iterate constraints to convergence.
+    Given circle centers, compute the maximal non-overlapping radii
+    within the unit square by iterative constraint enforcement.
     """
     n = centers.shape[0]
-    xs, ys = centers[:,0], centers[:,1]
-    radii = np.minimum.reduce([xs, ys, 1-xs, 1-ys])
-    # Iterate until convergence
-    for _ in range(20):
+    # Start with border‐limited radii
+    radii = np.minimum.reduce([
+        centers[:, 0], centers[:, 1],
+        1 - centers[:, 0], 1 - centers[:, 1]
+    ])
+
+    # Iteratively enforce pairwise non‐overlap
+    for _ in range(25):
         changed = False
         for i in range(n):
             for j in range(i+1, n):
-                d = np.linalg.norm(centers[i]-centers[j])
-                if radii[i]+radii[j] > d:
-                    scale = d/(radii[i]+radii[j]+1e-12)
-                    oldi, oldj = radii[i], radii[j]
+                d = np.linalg.norm(centers[i] - centers[j])
+                if radii[i] + radii[j] > d:
+                    scale = d / (radii[i] + radii[j] + 1e-12)
+                    old_i, old_j = radii[i], radii[j]
                     radii[i] *= scale
                     radii[j] *= scale
-                    if abs(radii[i]-oldi)>1e-8 or abs(radii[j]-oldj)>1e-8:
+                    if abs(radii[i] - old_i) > 1e-8 or abs(radii[j] - old_j) > 1e-8:
                         changed = True
         if not changed:
             break
+
     return radii
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii
