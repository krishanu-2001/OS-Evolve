<NAME>
targeted_gap_sampling_and_voronoi_refresh
</NAME>

<DESCRIPTION>
The current gap-driven Voronoi initialization only considers Voronoi vertices as candidate points for placing new circles, but it does not exploit local voids after each placement. Also, the Voronoi diagram is only recomputed after each placement, but the set of candidate points is not diversified enough to capture all significant gapsâ€”especially those arising between closely packed circles and between circles and boundaries.

To improve, after each new circle placement, we will:
1. Identify and sample additional candidate points in the largest local voids, by:
   - Sampling midpoints between pairs of most-distant existing centers (that are not already too close to existing centers).
   - Sampling points along the edges and near the center of the square if those regions are underpopulated.
2. After every 4 placements, refresh the Voronoi diagram to generate new candidate points, but also add these sampled points to the candidate set.
3. When selecting the next placement, choose the candidate point (from both Voronoi vertices and sampled voids) with the largest minimal distance to existing centers and boundaries.

This hybrid, targeted gap sampling and Voronoi refresh approach leverages both global and local void information, leading to a denser and more robust initial packing. This should provide a better starting point for subsequent optimization, potentially increasing the final combined score.

</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def gap_driven_init(n, margin, rng):
    """
    Initialize circle centers by iteratively placing circles in the largest gaps identified by Voronoi vertices,
    prioritizing corners and edges first, then filling interior gaps.
    This approach aims to maximize initial coverage and exploit geometric voids.
    """
    centers = []
    # Start with 4 large circles near corners to reduce edge effects
    corner_offset = 0.06
    corners = np.array([
        [margin + corner_offset, margin + corner_offset],
        [1 - margin - corner_offset, margin + corner_offset],
        [margin + corner_offset, 1 - margin - corner_offset],
        [1 - margin - corner_offset, 1 - margin - corner_offset],
    ])
    centers.extend(corners.tolist())

    # Add 6 medium circles along edges evenly spaced (3 per side, bottom and left)
    edge_positions = np.linspace(margin + 0.1, 1 - margin - 0.1, 3)
    # Bottom edge (excluding corners)
    for x in edge_positions:
        centers.append([x, margin + 0.06])
    # Left edge (excluding corners)
    for y in edge_positions:
        centers.append([margin + 0.06, y])

    # Now we have 4 + 6 = 10 circles placed, need to place 16 more inside

    # Initialize with these 10 points
    centers_arr = np.array(centers)

    # Iteratively place remaining circles in largest Voronoi vertex gaps
    for _ in range(n - len(centers)):
        # Compute Voronoi diagram of current centers plus 4 boundary points to bound the region
        # Add 4 points outside the unit square to bound Voronoi
        bounding_pts = np.array([
            [-1, -1], [-1, 2], [2, -1], [2, 2]
        ])
        all_pts = np.vstack([centers_arr, bounding_pts])
        vor = Voronoi(all_pts)

        # Candidate points are Voronoi vertices inside the unit square with margin
        candidates = []
        for v in vor.vertices:
            if margin <= v[0] <= 1 - margin and margin <= v[1] <= 1 - margin:
                candidates.append(v)
        if not candidates:
            # If no candidates, place random point inside margin
            new_center = rng.uniform(margin, 1 - margin, size=2)
            centers_arr = np.vstack([centers_arr, new_center])
            continue

        candidates = np.array(candidates)

        # For each candidate, compute minimal distance to existing centers and to boundary
        tree = cKDTree(centers_arr)
        dists, _ = tree.query(candidates, k=1)
        dist_to_boundary = np.minimum.reduce([
            candidates[:,0] - margin,
            candidates[:,1] - margin,
            (1 - margin) - candidates[:,0],
            (1 - margin) - candidates[:,1]
        ])
        # The maximal radius possible at candidate is min(dist_to_nearest_center, dist_to_boundary)
        max_radii = np.minimum(dists, dist_to_boundary)

        # Select candidate with largest max radius
        idx = np.argmax(max_radii)
        new_center = candidates[idx]

        # Add small random jitter to avoid perfect symmetry
        jitter = rng.uniform(-0.005, 0.005, size=2)
        new_center = np.clip(new_center + jitter, margin, 1 - margin)

        centers_arr = np.vstack([centers_arr, new_center])

    return centers_arr
=======
def gap_driven_init(n, margin, rng):
    """
    Hybrid targeted gap sampling and Voronoi-based initialization:
    - Place circles in largest gaps identified by Voronoi vertices,
      and also sample targeted voids (midpoints of distant pairs, underpopulated edge/center regions).
    - Periodically refresh Voronoi diagram and candidate set.
    This approach aims to maximize initial coverage and exploit both global and local geometric voids.
    """
    centers = []
    # Start with 4 large circles near corners to reduce edge effects
    corner_offset = 0.06
    corners = np.array([
        [margin + corner_offset, margin + corner_offset],
        [1 - margin - corner_offset, margin + corner_offset],
        [margin + corner_offset, 1 - margin - corner_offset],
        [1 - margin - corner_offset, 1 - margin - corner_offset],
    ])
    centers.extend(corners.tolist())

    # Add 6 medium circles along edges evenly spaced (3 per side, bottom and left)
    edge_positions = np.linspace(margin + 0.1, 1 - margin - 0.1, 3)
    # Bottom edge (excluding corners)
    for x in edge_positions:
        centers.append([x, margin + 0.06])
    # Left edge (excluding corners)
    for y in edge_positions:
        centers.append([margin + 0.06, y])

    # Now we have 4 + 6 = 10 circles placed, need to place 16 more inside

    centers_arr = np.array(centers)

    for idx_place in range(n - len(centers)):
        # --- Voronoi-based candidates ---
        bounding_pts = np.array([
            [-1, -1], [-1, 2], [2, -1], [2, 2]
        ])
        all_pts = np.vstack([centers_arr, bounding_pts])
        vor = Voronoi(all_pts)

        # Voronoi vertices inside the unit square with margin
        vor_candidates = []
        for v in vor.vertices:
            if margin <= v[0] <= 1 - margin and margin <= v[1] <= 1 - margin:
                vor_candidates.append(v)
        vor_candidates = np.array(vor_candidates) if len(vor_candidates) > 0 else np.zeros((0,2))

        # --- Targeted gap candidates ---
        # 1. Midpoints between most distant pairs (avoid those too close to existing centers)
        tree = cKDTree(centers_arr)
        candidate_midpoints = []
        if len(centers_arr) > 2:
            # Find the 4 most distant pairs
            dmat = np.linalg.norm(centers_arr[None,:,:] - centers_arr[:,None,:], axis=2)
            inds = np.dstack(np.unravel_index(np.argsort(-dmat.ravel()), dmat.shape))[0]
            midpoints = []
            count = 0
            for i,j in inds:
                if i >= j:
                    continue
                midpoint = (centers_arr[i] + centers_arr[j]) / 2
                if margin <= midpoint[0] <= 1 - margin and margin <= midpoint[1] <= 1 - margin:
                    # Only add if not too close to existing
                    min_dist, _ = tree.query(midpoint, k=1)
                    if min_dist > 0.12:
                        midpoints.append(midpoint)
                        count += 1
                if count >= 4:
                    break
            if midpoints:
                candidate_midpoints = np.array(midpoints)
            else:
                candidate_midpoints = np.zeros((0,2))
        else:
            candidate_midpoints = np.zeros((0,2))

        # 2. Edge and center sampling if underpopulated
        # Sample at square center if no circle within 0.15 of center
        center_pt = np.array([[0.5, 0.5]])
        min_dist_center, _ = tree.query(center_pt, k=1)
        center_candidate = center_pt if min_dist_center[0] > 0.15 else np.zeros((0,2))
        # Sample at midpoints of each edge if underpopulated
        edge_pts = np.array([
            [0.5, margin + 0.06],
            [0.5, 1 - margin - 0.06],
            [margin + 0.06, 0.5],
            [1 - margin - 0.06, 0.5]
        ])
        edge_candidates = []
        for pt in edge_pts:
            min_dist, _ = tree.query(pt, k=1)
            if min_dist > 0.13:
                edge_candidates.append(pt)
        edge_candidates = np.array(edge_candidates) if edge_candidates else np.zeros((0,2))

        # Combine all candidates
        candidates = np.vstack([
            vor_candidates,
            candidate_midpoints,
            center_candidate,
            edge_candidates
        ]) if vor_candidates.shape[0] + candidate_midpoints.shape[0] + center_candidate.shape[0] + edge_candidates.shape[0] > 0 else np.zeros((0,2))

        # If no candidates, place random point inside margin
        if candidates.shape[0] == 0:
            new_center = rng.uniform(margin, 1 - margin, size=2)
            centers_arr = np.vstack([centers_arr, new_center])
            continue

        # For each candidate, compute minimal distance to existing centers and to boundary
        dists, _ = tree.query(candidates, k=1)
        dist_to_boundary = np.minimum.reduce([
            candidates[:,0] - margin,
            candidates[:,1] - margin,
            (1 - margin) - candidates[:,0],
            (1 - margin) - candidates[:,1]
        ])
        max_radii = np.minimum(dists, dist_to_boundary)

        # Select candidate with largest max radius
        best_idx = np.argmax(max_radii)
        new_center = candidates[best_idx]

        # Add small random jitter to avoid perfect symmetry
        jitter = rng.uniform(-0.005, 0.005, size=2)
        new_center = np.clip(new_center + jitter, margin, 1 - margin)

        centers_arr = np.vstack([centers_arr, new_center])

        # After every 4 placements, refresh Voronoi diagram and candidate set (implicitly done by loop)

    return centers_arr
>>>>>>> REPLACE

</DIFF>