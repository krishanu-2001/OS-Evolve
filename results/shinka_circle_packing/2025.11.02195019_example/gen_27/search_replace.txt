<NAME>
iterative_radii_refinement_with_border_and_pairwise_constraints
</NAME>

<DESCRIPTION>
Replace the current single-pass radii adjustment with an iterative refinement that enforces border and pairwise constraints until convergence. This approach ensures maximal radii by repeatedly tightening constraints, which is known to improve packing density. The iterative approach is more robust than a single scaling pass and can better handle complex overlaps, especially near edges and corners.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
def compute_max_radii(centers):
    """
    Compute the maximum possible radii for each circle position
    such that they don't overlap and stay within the unit square.

    Args:
        centers: np.array of shape (n, 2) with (x, y) coordinates

    Returns:
        np.array of shape (n) with radius of each circle
    """
    n = centers.shape[0]
    radii = np.ones(n)

    # First, limit by distance to square borders
    for i in range(n):
        x, y = centers[i]
        # Distance to borders
        radii[i] = min(x, y, 1 - x, 1 - y)

    # Then, iteratively enforce distance constraints until convergence
    max_iter = 100
    tol = 1e-6
    for _ in range(max_iter):
        max_change = 0
        for i in range(n):
            for j in range(i + 1, n):
                dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))
                if radii[i] + radii[j] > dist:
                    scale = dist / (radii[i] + radii[j])
                    new_ri = radii[i] * scale
                    new_rj = radii[j] * scale
                    max_change = max(max_change,
                                     abs(radii[i] - new_ri),
                                     abs(radii[j] - new_rj))
                    radii[i] = new_ri
                    radii[j] = new_rj
        if max_change < tol:
            break

    return radii
=======
def compute_max_radii(centers):
    """
    Compute the maximum possible radii for each circle position
    such that they don't overlap and stay within the unit square.

    Args:
        centers: np.array of shape (n, 2) with (x, y) coordinates

    Returns:
        np.array of shape (n) with radius of each circle
    """
    n = centers.shape[0]
    radii = np.ones(n)

    # Initialize radii by border distance
    for i in range(n):
        x, y = centers[i]
        radii[i] = min(x, y, 1 - x, 1 - y)

    # Iteratively enforce pairwise and border constraints until convergence
    max_iter = 200
    tol = 1e-8
    for _ in range(max_iter):
        max_change = 0
        # Enforce pairwise constraints
        for i in range(n):
            for j in range(i + 1, n):
                dist = np.linalg.norm(centers[i] - centers[j])
                if radii[i] + radii[j] > dist:
                    excess = radii[i] + radii[j] - dist
                    share = 0.5 * excess
                    new_ri = max(radii[i] - share, 1e-8)
                    new_rj = max(radii[j] - share, 1e-8)
                    max_change = max(max_change,
                                     abs(radii[i] - new_ri),
                                     abs(radii[j] - new_rj))
                    radii[i] = new_ri
                    radii[j] = new_rj
        # Enforce border constraints again (in case radii grew too large)
        for i in range(n):
            x, y = centers[i]
            border_limit = min(x, y, 1 - x, 1 - y)
            if radii[i] > border_limit:
                max_change = max(max_change, radii[i] - border_limit)
                radii[i] = border_limit
        if max_change < tol:
            break

    return radii
>>>>>>> REPLACE