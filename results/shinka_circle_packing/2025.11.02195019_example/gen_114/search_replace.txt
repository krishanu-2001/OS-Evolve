<NAME>
add_corner_and_edge_large_circles_initialization
</NAME>

<DESCRIPTION>
Introduce a strategic initialization placing larger circles at corners and edges of the unit square, with smaller circles filling the center region. This exploits the insight that placing larger circles near edges and corners can improve packing efficiency and sum of radii, as edge effects reduce the effective packing density. By fixing large circles at corners and edges initially, the relaxation and annealing phases can better optimize the remaining smaller circles in the center, potentially increasing the total sum of radii.
</DESCRIPTION>

<DIFF>
<<<<<<< SEARCH
    # 1) Initialize on a hexagonal lattice in [0.05,0.95]^2, pick n best by border distance, then jitter
    m = int(np.ceil(np.sqrt(n/0.866)))  # estimate rows needed for hex density
    dx = 0.9 / (m - 1)
    dy = dx * np.sqrt(3) / 2
    hex_pts = []
    for i in range(m):
        for j in range(m):
            x = 0.05 + j * dx + (i % 2) * (dx / 2)
            y = 0.05 + i * dy
            if x <= 0.95 and y <= 0.95:
                hex_pts.append((x, y))
    hex_pts = np.array(hex_pts)
    # score by distance to borders
    d_border = np.minimum.reduce([hex_pts, 1 - hex_pts], axis=0).min(axis=1)
    idx = np.argsort(-d_border)[:n]
    centers = hex_pts[idx].copy()
    # jitter to break symmetry
    centers += (np.random.rand(n, 2) - 0.5) * 0.02
    centers = np.clip(centers, 0.01, 0.99)
=======
    # 1) Strategic initialization: place 4 large circles at corners, 8 medium at edges, rest in center hex lattice
    centers = np.zeros((n, 2))
    # Large corner circles (4)
    corner_r = 0.12
    corners = np.array([[corner_r, corner_r],
                        [1 - corner_r, corner_r],
                        [corner_r, 1 - corner_r],
                        [1 - corner_r, 1 - corner_r]])
    centers[0:4] = corners
    # Medium edge circles (8): evenly spaced on edges between corners
    edge_r = 0.07
    edge_positions = []
    # bottom edge
    xs = np.linspace(corner_r*2, 1 - corner_r*2, 4)
    for x in xs:
        edge_positions.append([x, edge_r])
    # top edge
    for x in xs:
        edge_positions.append([x, 1 - edge_r])
    centers[4:12] = np.array(edge_positions)
    # Left and right edge circles (4)
    ys = np.linspace(corner_r*2, 1 - corner_r*2, 4)
    left_right_edges = []
    for y in ys:
        left_right_edges.append([edge_r, y])
    for y in ys:
        left_right_edges.append([1 - edge_r, y])
    centers = np.vstack([centers[:12], np.array(left_right_edges)])
    # Now fill remaining centers with hex lattice points inside center square [0.2,0.8]^2
    remaining = n - centers.shape[0]
    m = int(np.ceil(np.sqrt(remaining / 0.866)))  # hex grid rows estimate
    dx = 0.6 / (m - 1)
    dy = dx * np.sqrt(3) / 2
    hex_pts = []
    for i in range(m):
        for j in range(m):
            x = 0.2 + j * dx + (i % 2) * (dx / 2)
            y = 0.2 + i * dy
            if x <= 0.8 and y <= 0.8:
                hex_pts.append((x, y))
    hex_pts = np.array(hex_pts)
    # Select closest remaining points to center (0.5,0.5)
    center_point = np.array([0.5, 0.5])
    d_center = np.linalg.norm(hex_pts - center_point, axis=1)
    idx = np.argsort(d_center)[:remaining]
    centers = np.vstack([centers, hex_pts[idx]])
    # Jitter small random noise to break symmetry
    centers += (np.random.rand(n, 2) - 0.5) * 0.01
    centers = np.clip(centers, 0.01, 0.99)
>>>>>>> REPLACE