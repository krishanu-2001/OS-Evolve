--- a/original.py
+++ b/original.py
@@ -1,101 +1,158 @@
 # EVOLVE-BLOCK-START
 """Hybrid hexagonal initialization + hill‐climbing for n=26 circle packing"""
 
 import numpy as np
 
 def construct_packing():
     """
     Initialize 26 circle centers on a hexagonal lattice, then perform
     a hill-climbing local search to maximize the sum of radii.
     Returns:
         centers: np.array (26,2)
         radii:   np.array (26,)
     """
     n = 26
     # Row layout: sums to 26
     row_counts = [6, 5, 6, 5, 4]
     max_cols = max(row_counts)
     margin = 0.02
     dx = (1 - 2*margin) / max_cols
     h  = dx * np.sqrt(3) / 2
 
     # Build initial hex grid
     centers = np.zeros((n, 2))
     idx = 0
     for rid, cnt in enumerate(row_counts):
         x_start = margin + (max_cols - cnt) * dx / 2
         y = margin + rid * h
         for c in range(cnt):
             centers[idx, 0] = x_start + c * dx
             centers[idx, 1] = y
             idx += 1
 
     # Compute initial radii & sum
     best_centers = centers.copy()
     best_radii   = compute_max_radii(best_centers)
     best_sum     = best_radii.sum()
 
     # Hill‐climbing parameters
     iters = 5000
     initial_alpha = dx * 0.5
     rng = np.random.default_rng(42)
 
     for t in range(iters):
         # decaying step size
         alpha = initial_alpha * (1 - t / iters)
         i = int(rng.integers(n))
         cand_centers = best_centers.copy()
         # random perturbation
         delta = rng.uniform(-alpha, alpha, size=2)
         cand_centers[i] += delta
         # keep inside margins
         cand_centers[i] = np.clip(cand_centers[i], margin, 1 - margin)
         # recompute radii & evaluate
         cand_radii = compute_max_radii(cand_centers)
         s = cand_radii.sum()
         if s > best_sum:
             best_sum     = s
             best_centers = cand_centers
             best_radii   = cand_radii
 
+    # --- Physics-inspired relaxation refinement ---
+    best_centers = physics_relaxation(best_centers, best_radii, steps=50, margin=margin)
+    best_radii = compute_max_radii(best_centers)
     return best_centers, best_radii
 
+
+def physics_relaxation(centers, radii, steps=50, margin=0.02):
+    """
+    Physics-inspired repulsive force refinement of circle centers.
+    Args:
+        centers: (n,2) array of current centers
+        radii:   (n,) array of current radii
+        steps:   number of force relaxation steps
+        margin:  margin from square boundary
+    Returns:
+        refined_centers: (n,2) array
+    """
+    n = centers.shape[0]
+    centers = centers.copy()
+    for _ in range(steps):
+        forces = np.zeros_like(centers)
+        # Pairwise repulsive forces for overlap or near-overlap
+        for i in range(n):
+            for j in range(i+1, n):
+                d_vec = centers[j] - centers[i]
+                dist = np.linalg.norm(d_vec)
+                min_dist = radii[i] + radii[j] + 1e-6
+                if dist < min_dist:
+                    # Repulsive force proportional to overlap
+                    if dist > 1e-8:
+                        direction = d_vec / dist
+                    else:
+                        direction = np.random.uniform(-1,1,2)
+                        direction /= np.linalg.norm(direction)
+                    overlap = min_dist - dist
+                    f = 0.2 * overlap * direction
+                    forces[i] -= f
+                    forces[j] += f
+        # Boundary repulsion
+        for i in range(n):
+            x, y = centers[i]
+            r = radii[i]
+            # Left
+            if x - r < margin:
+                forces[i,0] += 0.2 * (margin - (x - r))
+            # Right
+            if x + r > 1 - margin:
+                forces[i,0] -= 0.2 * ((x + r) - (1 - margin))
+            # Bottom
+            if y - r < margin:
+                forces[i,1] += 0.2 * (margin - (y - r))
+            # Top
+            if y + r > 1 - margin:
+                forces[i,1] -= 0.2 * ((y + r) - (1 - margin))
+        # Update positions
+        centers += 0.15 * forces
+        # Keep in margins
+        centers = np.clip(centers, margin, 1 - margin)
+    return centers
 
 def compute_max_radii(centers):
     """
     Given circle centers, compute the maximal non-overlapping radii
     within the unit square by iteratively enforcing border and pairwise constraints.
     """
     n = centers.shape[0]
     radii = np.minimum.reduce([
         centers[:,0],            # distance to left
         centers[:,1],            # distance to bottom
         1 - centers[:,0],        # right
         1 - centers[:,1]         # top
     ])
 
     # Enforce non-overlap: for each pair, if sum > dist, scale both
     for i in range(n):
         for j in range(i+1, n):
             d = np.hypot(*(centers[i] - centers[j]))
             if d <= 0:
                 # coincident centers — collapse both
                 radii[i] = radii[j] = 0.0
             else:
                 ri, rj = radii[i], radii[j]
                 if ri + rj > d:
                     scale = d / (ri + rj)
                     radii[i] *= scale
                     radii[j] *= scale
     return radii
 
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii