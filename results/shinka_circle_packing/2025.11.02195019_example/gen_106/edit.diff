--- a/original.py
+++ b/original.py
@@ -1,175 +1,226 @@
 # EVOLVE-BLOCK-START
-"""Hybrid force-based + adaptive SA circle packing for n=26"""
+"""Hybrid corner-edge + hex lattice with adaptive SA and refined greedy for 26 circles"""
 
 import numpy as np
 
 def construct_packing():
     """
-    Construct and optimize an arrangement of 26 circles in a unit square
-    using hexagonal initialization, force-based relaxation,
-    adaptive simulated annealing with multi-circle moves,
-    and local greedy refinement.
+    Construct and optimize 26 circles in a unit square,
+    placing larger circles at corners and edges, 
+    hex lattice inside, then refining with physics,
+    adaptive simulated annealing, and exhaustive greedy.
     Returns:
         centers: np.array (26,2)
         radii:   np.array (26,)
     """
-    np.random.seed(42)
+    np.random.seed(1234)
     n = 26
 
-    # 1) Hexagonal lattice initialization within [0.05,0.95]^2
-    m = int(np.ceil(np.sqrt(n / 0.866)))
-    dx = 0.9 / (m - 1)
-    dy = dx * np.sqrt(3) / 2
+    # --- 1) Strategic initial placement: corners, edges + hex lattice interior ---
+
+    # Place 4 large circles near corners
+    corner_pos = np.array([
+        [0.05, 0.05],
+        [0.05, 0.95],
+        [0.95, 0.05],
+        [0.95, 0.95]
+    ])
+
+    # Place 4 intermediate large circles at midpoints of edges
+    edge_mid_pos = np.array([
+        [0.5, 0.05],
+        [0.5, 0.95],
+        [0.05, 0.5],
+        [0.95, 0.5]
+    ])
+
+    # Remaining 18 circles packed hexagonally in center region [0.15,0.85]^2
+    remaining = n - (len(corner_pos) + len(edge_mid_pos))
+    m = int(np.ceil(np.sqrt(remaining / 0.866)))  # hex density approx
+
+    dx = 0.7 / (m - 1)  # spacing in x in [0.15,0.85]
+    dy = dx * np.sqrt(3) / 2  # y spacing for hex lattice
+
     pts = []
     for i in range(m):
         for j in range(m):
-            x = 0.05 + j * dx + (i % 2) * (dx / 2)
-            y = 0.05 + i * dy
-            if x <= 0.95 and y <= 0.95:
-                pts.append((x, y))
+            x = 0.15 + j * dx + (i % 2) * dx/2
+            y = 0.15 + i * dy
+            if x <= 0.85 and y <= 0.85:
+                pts.append((x,y))
     pts = np.array(pts)
-    # Select top n by distance to border
-    d_border = np.min(np.stack([pts, 1 - pts], axis=2), axis=2).min(axis=1)
-    idx = np.argsort(-d_border)[:n]
-    centers = pts[idx].copy()
-    # Jitter to break symmetry
-    centers += (np.random.rand(n, 2) - 0.5) * 0.02
+
+    # Select closest 18 points to center to keep compactness
+    center_point = np.array([0.5,0.5])
+    dist_to_center = np.linalg.norm(pts - center_point, axis=1)
+    idx = np.argsort(dist_to_center)[:remaining]
+    hex_centers = pts[idx]
+
+    # Combine all centers
+    centers = np.vstack([corner_pos, edge_mid_pos, hex_centers])
+
+    # Add slight jitter to break symmetries
+    jitter = (np.random.rand(n,2) - 0.5) * 0.015 
+    centers += jitter
     centers = np.clip(centers, 0.01, 0.99)
 
-    # 2) Iterative radius computation and force-based relaxation
+    # --- 2) Force-based relaxation with careful step size and increased iterations ---
+
     radii = compute_max_radii(centers)
-    alpha = 0.025
-    for it in range(500):
+    alpha = 0.02
+    max_iters = 700
+
+    for it in range(max_iters):
         forces = np.zeros((n, 2))
 
-        # Pairwise overlap repulsion
+        # Overlap repulsion forces between circles
         for i in range(n):
-            for j in range(i + 1, n):
+            for j in range(i+1, n):
                 dxy = centers[i] - centers[j]
-                dist = np.hypot(dxy[0], dxy[1]) + 1e-8
-                allow = radii[i] + radii[j]
-                if dist < allow:
-                    overlap = (allow - dist) / dist
-                    forces[i] +=  dxy * overlap
-                    forces[j] -=  dxy * overlap
+                dist = np.hypot(dxy[0], dxy[1]) + 1e-12
+                allowed = radii[i] + radii[j]
+                if dist < allowed:
+                    overlap = (allowed - dist)/dist
+                    delta = dxy * overlap
+                    forces[i] += delta
+                    forces[j] -= delta
 
         # Border corrective forces
         for i in range(n):
-            x, y = centers[i]
+            x,y = centers[i]
             r = radii[i]
             if x - r < 0:
-                forces[i, 0] += (r - x)
+                forces[i,0] += (r - x)*1.2
             if x + r > 1:
-                forces[i, 0] -= (x + r - 1)
+                forces[i,0] -= (x + r -1)*1.2
             if y - r < 0:
-                forces[i, 1] += (r - y)
+                forces[i,1] += (r - y)*1.2
             if y + r > 1:
-                forces[i, 1] -= (y + r - 1)
-
-        # Update centers with decay on step size
+                forces[i,1] -= (y + r -1)*1.2
+
         centers += alpha * forces
         centers = np.clip(centers, 0.01, 0.99)
-
         radii = compute_max_radii(centers)
         alpha *= 0.995
 
-    # 3) Adaptive simulated annealing with multi-circle moves
+    # --- 3) Adaptive simulated annealing with multi-circle moves and dynamic schedule ---
+
     centers_sa = centers.copy()
     radii_sa = radii.copy()
-    sum_sa = radii_sa.sum()
-    best_centers = centers_sa.copy()
-    best_radii = radii_sa.copy()
-    best_sum = sum_sa
-
-    T = 0.002
-    cooling_rate = 0.995
-    max_T = 0.01
+    best_centers = centers.copy()
+    best_radii = radii.copy()
+    best_sum = np.sum(radii_sa)
+
+    T = 0.004
+    cooling = 0.9945
+    max_T = 0.015
     no_improve = 0
-
-    for k in range(1500):
-        if k % 100 == 0:
-            count = np.random.randint(2, 5)
+    stagnation_limit = 120
+
+    for it in range(1800):
+        # Multi-circle moves every 80 iterations for better exploration
+        if it % 80 == 0:
+            count = np.random.randint(2,5)
             idxs = np.random.choice(n, count, replace=False)
         else:
             idxs = [np.random.randint(n)]
+
         old_pos = centers_sa[idxs].copy()
-        scale = 0.006 * (1 - k / 1500)
+        scale = 0.007 * (1 - it/1800)
         delta = np.random.randn(len(idxs), 2) * scale
         centers_sa[idxs] = np.clip(centers_sa[idxs] + delta, 0.01, 0.99)
+
         radii_tmp = compute_max_radii(centers_sa)
         sum_new = np.sum(radii_tmp)
-        dE = sum_new - sum_sa
-        if dE > 0 or np.random.rand() < np.exp(dE / T):
-            sum_sa = sum_new
+        dE = sum_new - np.sum(radii_sa)
+
+        accept_prob = np.exp(dE / max(T,1e-12)) if dE < 0 else 1.0
+        if dE > 0 or np.random.rand() < accept_prob:
             radii_sa = radii_tmp
-            no_improve = 0
-            if sum_new > best_sum + 1e-8:
+            if sum_new > best_sum + 1e-9:
                 best_sum = sum_new
                 best_centers = centers_sa.copy()
                 best_radii = radii_tmp.copy()
+                no_improve = 0
+            else:
+                no_improve += 1
         else:
             centers_sa[idxs] = old_pos
             no_improve += 1
-        if no_improve > 100:
-            T = min(T * 1.1, max_T)
+
+        # Adaptive temperature control
+        if no_improve > stagnation_limit:
+            T = min(T * 1.15, max_T)
             no_improve = 0
         else:
-            T *= cooling_rate
+            T *= cooling
 
     centers, radii = best_centers.copy(), best_radii.copy()
 
-    # 4) Local greedy refinement to further improve sum of radii
-    directions = np.array([[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]])
+    # --- 4) Local greedy refinement with additional directions and finer stepsize ---
+
+    directions = np.array([
+        [1,0], [-1,0], [0,1], [0,-1],
+        [1,1], [1,-1], [-1,1], [-1,-1],
+        [2,1], [1,2], [-2,1], [-1,2],
+        [2,-1], [1,-2], [-2,-1], [-1,-2]
+    ])
+    directions = directions / np.linalg.norm(directions, axis=1)[:, None]
+
+    step_sizes = [0.008, 0.004, 0.002, 0.001]
+
     for i in range(n):
-        orig = centers[i].copy()
-        for step in [0.01, 0.005, 0.0025, 0.001]:
+        pos = centers[i].copy()
+        for step in step_sizes:
             improved = True
             while improved:
                 improved = False
                 for d in directions:
-                    cand = orig + d * step
+                    cand = pos + d * step
                     cand = np.clip(cand, 0.01, 0.99)
                     centers[i] = cand
                     radii_cand = compute_max_radii(centers)
                     if np.sum(radii_cand) > np.sum(radii):
                         radii = radii_cand
-                        orig = cand
+                        pos = cand
                         improved = True
-                centers[i] = orig
+                centers[i] = pos
 
     return centers, radii
 
 def compute_max_radii(centers):
     """
-    Given fixed centers, compute maximal radii within [0,1]^2 without overlap.
-    Uses iterative pairwise scaling until convergence.
+    Compute max radii for fixed centers in [0,1]^2 with no overlap,
+    using iterative relaxation scaling until convergence.
     """
     n = centers.shape[0]
     xs, ys = centers[:,0], centers[:,1]
-    radii = np.minimum.reduce([xs, ys, 1-xs, 1-ys])
-    for _ in range(50):
+    radii = np.minimum.reduce([xs, ys, 1 - xs, 1 - ys])
+
+    for _ in range(60):
         max_change = 0.0
         for i in range(n):
             for j in range(i+1, n):
                 dxy = centers[i] - centers[j]
-                dist = np.hypot(*dxy)
-                total = radii[i] + radii[j]
-                if total > dist and dist > 1e-12:
-                    scale = dist / total
+                dist = np.hypot(dxy[0], dxy[1])
+                max_sum = radii[i] + radii[j]
+                if max_sum > dist and dist > 1e-12:
+                    scale = dist / max_sum
                     old_i, old_j = radii[i], radii[j]
                     radii[i] *= scale
                     radii[j] *= scale
-                    max_change = max(max_change, abs(radii[i]-old_i), abs(radii[j]-old_j))
-        if max_change < 1e-6:
+                    max_change = max(max_change, abs(radii[i] - old_i), abs(radii[j] - old_j))
+        if max_change < 1e-7:
             break
+
     return radii
 # EVOLVE-BLOCK-END
 
 
 # This part remains fixed (not evolved)
 def run_packing():
     """Run the circle packing constructor for n=26"""
     centers, radii = construct_packing()
     # Calculate the sum of radii
     sum_radii = np.sum(radii)
     return centers, radii, sum_radii